<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[plscope-utils Reports]]></name>
	<tooltip><![CDATA[PL/Scope reports]]></tooltip>
	<description><![CDATA[PL/Scope reports provided by plscope-utils, see https://github.com/PhilippSalvisberg/plscope-utils ]]></description>
		<display id="1dc49f53-015d-1000-8001-c0a8011251fe" type="" style="Table" enable="true">
		<name><![CDATA[Duplicate SQL Statements]]></name>
		<description><![CDATA[Reports duplicate static SQL statements within packages, procedures, functions, triggers and types. ]]></description>
		<tooltip><![CDATA[Reports duplicate static SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   stmt as (
      select owner,
             object_type,
             object_name,
             type,
             line,
             col,
             sql_id,
             case
                when (count(sql_id) over (partition by sql_id)) > 1 then
                   'YES'
                else
                   'NO'
             end as is_duplicate,
             full_text
        from sys.all_statements
       where owner like nvl(:OBJECT_OWNER, user)
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       type as "Type",
       line as "Line",
       col as "Col",
       sql_id as "SQL_ID",
       full_text as "Text"
  from stmt
 where is_duplicate = 'YES'
 order by owner, object_type, object_name, sql_id, line, col
]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					
					null															</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27802dea-015d-1000-8001-c0a80106a1a4" type="" style="Table" enable="true">
		<name><![CDATA[UDF Calls in SQL Statements]]></name>
		<description><![CDATA[Reports static SELECT, INSERT, UPDATE, DELETE and MERGE statements within packages, procedures, functions, triggers and types using user-defined function calls.]]></description>
		<tooltip><![CDATA[Reports user-defined function calls in SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             ':' || nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             replace(sys_connect_by_path(ids.name, '|'), '|', '/') as name_path,
             level as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from ids
       start with ids.usage_context_id = 0
     connect by prior ids.usage_id = ids.usage_context_id
         and prior ids.owner = ids.owner
         and prior ids.object_type = ids.object_type
         and prior ids.object_name = ids.object_name
   ),
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             regexp_replace(src.text, chr(10) || '+$', null) text, -- remove trailing new line character
             case
                when tree.name_path like '%:%'
                   and tree.usage != 'EXECUTE'
                then
                   -- ensure that this is really a child of a statement
                   last_value (
                      case
                         when tree.usage = 'EXECUTE' then
                            tree.type
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_name, tree.object_type
                      order by tree.line, tree.col, tree.path_len
                   )
             end as parent_statement_type,
             case
                when tree.name_path like '%:%'
                   and tree.usage != 'EXECUTE'
                then
                   -- ensure that this is really a child of a statement
                   last_value (
                      case
                         when tree.usage = 'EXECUTE' then
                            tree.path_len
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_name, tree.object_type
                      order by tree.line, tree.col, tree.path_len
                   )
             end as parent_statement_path_len,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       parent_statement_type as "Statement type",
       name as "Function name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where parent_statement_type in ('SELECT', 'INSERT', 'UPDATE', 'DETETE', 'MERGE')
   and type = 'FUNCTION'
   and usage = 'CALL'
   -- ensure function call is part of the parent statement
   and (parent_statement_path_len >= path_len - 2)
   -- do not report function calls from standard package such as USER, REPLACE, SUBSTR, etc.
   and not (ref_owner = 'SYS' and ref_object_type = 'PACKAGE' and ref_object_name = 'STANDARD')
 order by owner, object_type, object_name, line, col
 ]]>
            </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27d1dbe9-015d-1000-8001-c0a801060752" type="" style="Table" enable="true">
		<name><![CDATA[CRUD Operations]]></name>
		<description><![CDATA[Reports static usages of tables/views/synonyms within packages, procedures, functions, triggers and types. Reports number of SELECT, INSERT, UPDATE, DELETE, MERGE, REFERENCE usages per PL/SQL unit ]]></description>
		<tooltip><![CDATA[Number of select, insert, update, delete, merge, reference usages per PL/SQL unit.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   dep as (
      select owner as owner,
             'TABLE' as type,
             table_name as name,
             null as referenced_owner,
             null as referenced_type,
             null as referenced_name
        from sys.all_tables
      union all
      select owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        from sys.all_dependencies
       where type in ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   dep_graph as (
      select distinct
             owner,
             type as object_type,
             name as object_name,
             connect_by_root(owner) as ref_owner,
             connect_by_root(type) as ref_object_type,
             connect_by_root(name) as ref_object_name,
             sys_connect_by_path(type, '/') as ref_object_type_path,
             level as path_len
        from dep
     connect by prior dep.owner = dep.referenced_owner
         and prior dep.type = dep.referenced_type
         and prior dep.name = dep.referenced_name
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             ':' || nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             replace(sys_connect_by_path(ids.name, '|'), '|', '/') as name_path,
             level as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from ids
       start with ids.usage_context_id = 0
     connect by prior ids.usage_id = ids.usage_context_id
         and prior ids.owner = ids.owner
         and prior ids.object_type = ids.object_type
         and prior ids.object_name = ids.object_name
   ),
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             replace(tree.name_path, ':', null) as name_path, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             regexp_replace(src.text, chr(10) || '+$', null) text, -- remove trailing new line character
             case
                when tree.name_path like '%:%'
                   and tree.usage != 'EXECUTE'
                then
                   -- ensure that this is really a child of a statement
                   last_value (
                      case
                         when tree.usage = 'EXECUTE' then
                            tree.signature
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_name, tree.object_type
                      order by tree.line, tree.col, tree.path_len
                   )
             end as parent_statement_signature,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   ),
   tab_usage as (
      select /*+use_hash(ids) use_hash(dep_graph) use_hash(refs)*/
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             case
                when dep_graph.path_len = 1 then
                   'YES'
                else
                   'NO'
             end as direct_dependency,
             dep_graph.ref_object_type_path,
             lead(dep_graph.ref_object_type_path) over (
                order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col, dep_graph.path_len
             ) as next_ref_object_type_path,
             ids.text
        from plscope_identifiers ids
        join dep_graph
          on dep_graph.owner = ids.ref_owner
         and dep_graph.object_type = ids.ref_object_type
         and dep_graph.object_name = ids.ref_object_name
        left join sys.all_statements refs
          on refs.signature = parent_statement_signature
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
   ),
   plscope_tab_usage as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             direct_dependency,
             text
        from tab_usage
       where (ref_object_type != 'SYNONYM' or next_ref_object_type_path in ('/VIEW/SYNONYM', '/TABLE/SYNONYM'))
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(min(line), 'FM0000009')
             || ':'
             || to_char(1, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       ref_owner as "Ref Owner",
       ref_object_type "Ref object type",
       ref_object_name "Ref object name",
       sum(case
             when operation = 'SELECT' then
                1
             else
                0
          end) as "Select",
       sum(case
             when operation = 'INSERT' then
                1
             else
                0
          end) as "Insert",
       sum(case
             when operation = 'UPDATE' then
                1
             else
                0
          end) as "Update",
       sum(case
             when operation = 'DELETE' then
                1
             else
                0
          end) as "Delete",
       sum(case
             when operation = 'MERGE' then
                1
             else
                0
          end) as "Merge",
       sum(case
             when operation = 'REFERENCE' then
                1
             else
                0
          end) as "Reference"
  from plscope_tab_usage
 where operation in ('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'MERGE', 'REFERENCE')
   and direct_dependency = 'YES'
 group by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name
 order by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="2e3cb6a6-015d-1000-8001-c0a801126c36" type="" style="Table" enable="true">
		<name><![CDATA[Unused Local Identifiers]]></name>
		<description><![CDATA[Reports locally declared identifiers in within packages, procedures, functions, triggers and types which are not referenced.]]></description>
		<tooltip><![CDATA[Reports unreferenced locally defined identifiers]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             ':' || nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             replace(sys_connect_by_path(ids.name, '|'), '|', '/') as name_path,
             level as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from ids
       start with ids.usage_context_id = 0
     connect by prior ids.usage_id = ids.usage_context_id
         and prior ids.owner = ids.owner
         and prior ids.object_type = ids.object_type
         and prior ids.object_name = ids.object_name
   ),
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             replace(tree.name_path, ':', null) as name_path, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             regexp_replace(src.text, chr(10) || '+$', null) text, -- remove trailing new line character
             case
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used, -- wrong result, if used in statements which do not register usage, such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE. Bug 26351814.
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where usage = 'DECLARATION'
   and is_used = 'NO'
 order by owner, object_type, object_name, line, col
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query minversion="11.1">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             replace(sys_connect_by_path(ids.name, '|'), '|', '/') as name_path,
             level as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from ids
       start with ids.usage_context_id = 0
     connect by prior ids.usage_id = ids.usage_context_id
         and prior ids.owner = ids.owner
         and prior ids.object_type = ids.object_type
         and prior ids.object_name = ids.object_name
   ),
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             replace(tree.name_path, ':', null) as name_path, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             regexp_replace(src.text, chr(10) || '+$', null) text, -- remove trailing new line character
             case
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used, -- wrong result, if used in statements which do not register usage, such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE. Bug 26351814.
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where usage = 'DECLARATION'
   and is_used = 'NO'
 order by owner, object_type, object_name, line, col
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="9f38924a-015d-1000-8001-c0a80112c4cd" type="" style="Table" enable="true">
		<name><![CDATA[PL/SQL Naming Conventions]]></name>
		<description><![CDATA[Check PL/SQL identifiers based on the Trivadis PL/SQL & SQL Coding Guidelines V3.2]]></description>
		<tooltip><![CDATA[Reports PL/SQL identifiers violationg naming conventions]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="11.1">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   ids as (
      select owner,
             name,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   tree as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             level as path_len,
             ids.type,
             sys_connect_by_path(ids.type, '/') as type_path,
             ids.usage,
             ids.usage_id,
             ids.usage_context_id,
             prior ids.type as parent_type,
             prior ids.usage as parent_usage,
             prior ids.line as parent_line,
             prior ids.col as parent_col,
             prior ids.name as parent_name
        from ids
       start with ids.usage_context_id = 0
     connect by prior ids.usage_id = ids.usage_context_id
         and prior ids.owner = ids.owner
         and prior ids.object_type = ids.object_type
         and prior ids.object_name = ids.object_name
   ),
   prepared as (
      select tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             regexp_replace(src.text, chr(10) || '+$', null) text, -- remove trailing new line character
             tree.usage,
             tree.type,
             tree.name,
             tree.line,
             tree.col,
             tree.type_path,
             tree.parent_usage,
             tree.parent_type,
             tree.parent_name,
             tree.parent_line,
             tree.parent_col
        from tree
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
       where tree.object_type in ('FUNCTION', 'PROCEDURE', 'TRIGGER', 'PACKAGE', 'PACKAGE BODY', 'TYPE', 'TYPE BODY')
   ),
   checked as (
      select owner,
             object_type,
             object_name,
             procedure_name,
             case
                when usage = 'REFERENCE' then
                   parent_usage
                else
                   usage
             end as usage,
             case
                when usage = 'REFERENCE' then
                   parent_type
                else
                   type
             end as type,
             case
                when usage = 'REFERENCE' then
                   parent_name
                else
                   name
             end as name,
             case
                   -- global variables (all types)
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and regexp_like(type_path, '/PACKAGE/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*'), 'i') then
                         'OK'
                      else
                         'Global variable does not match regex "'
                         || nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*')
                         || '".'
                   end 
                   -- local record variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and (type = 'RECORD' or regexp_like(text, '.*%\s*rowtype.*', 'i'))
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*'), 'i') then
                         'OK'
                      else
                         'Local record variable does not match regex "'
                         || nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*')
                         || '".'
                   end
                   -- local array/table variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and type in ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*'), 'i') then
                         'OK'
                      else
                         'Local array/table variable does not match regex "'
                         || nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*')
                         || '".'
                   end
                   -- local object variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and type = 'OBJECT'
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*'), 'i') then
                         'OK'
                      else
                         'Local object variable does not match regex "'
                         || nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*')
                         || '".'
                   end
                   -- local variables for other types
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_VARIABLE_REGEX, '^(l|c)_.*'), 'i') then
                         'OK'
                      else
                         'Local variable does not match regex "'
                         || nvl(:LOCAL_VARIABLE_REGEX, '^(l|c)_.*')
                         || '".'
                   end
                   -- cursors
                when usage = 'DECLARATION'
                   and type = 'CURSOR'
                then
                   case
                      when regexp_like(name, nvl(:CURSOR_REGEX, '^c_.*'), 'i') then
                         'OK'
                      else
                         'Cursor does not match regex "'
                         || nvl(:CURSOR_REGEX, '^c_.*')
                         || '".'
                   end
                   -- cursor parameters
                when parent_usage = 'DECLARATION'
                   and parent_type = 'CURSOR'
                   and usage = 'DECLARATION'
                   and type like 'FORMAL%'
                then
                   case
                      when regexp_like(name, nvl(:CURSOR_PARAMETER_REGEX, '^p_.*'), 'i') then
                         'OK'
                      else
                         'Cursor parameter does not match regex "'
                         || nvl(:CURSOR_PARAMETER_REGEX, '^p_.*')
                         || '".'
                   end
                   -- IN parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL IN'
                then
                   case
                      when regexp_like(name, nvl(:IN_PARAMETER_REGEX, '^in_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'IN parameter does not match regex "'
                         || nvl(:IN_PARAMETER_REGEX, '^in_.*')
                         || '".'
                   end
                   -- OUT parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL OUT'
                then
                   case
                      when regexp_like(name, nvl(:OUT_PARAMETER_REGEX, '^out_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'OUT parameter does not match regex "'
                         || nvl(:OUT_PARAMETER_REGEX, '^out_.*')
                         || '".'
                   end
                   -- IN OUT parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL IN OUT'
                then
                   case
                      when regexp_like(name, nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'IN OUT parameter does not match regex "'
                         || nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*')
                         || '".'
                   end
                   -- records
                when usage = 'DECLARATION'
                   and type = 'RECORD'
                then
                   case
                      when regexp_like(name, nvl(:RECORD_REGEX, '^r_.*_type$'), 'i') then
                         'OK'
                      else
                         'Record does not match regex "'
                         || nvl(:RECORD_REGEX, '^r_.*_type$')
                         || '".'
                   end
                   -- arrays/tables
                when usage = 'DECLARATION'
                   and type in ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                then
                   case
                      when regexp_like(name, nvl(:ARRAY_REGEX, '^t_.*_type$'), 'i') then
                         'OK'
                      else
                         'Array/table does not match regex "'
                         || nvl(:ARRAY_REGEX, '^t_.*_type$')
                         || '".'
                   end
                   -- exceptions
                when usage = 'DECLARATION'
                   and type = 'EXCEPTION'
                then
                   case
                      when regexp_like(name, nvl(:EXCEPTION_REGEX, '^e_.*'), 'i') then
                         'OK'
                      else
                         'Exception does not match regex "'
                         || nvl(:EXCEPTION_REGEX, '^e_.*')
                         || '".'
                   end
                   -- constants
                when usage = 'DECLARATION'
                   and type = 'CONSTANT'
                then
                   case
                      when regexp_like(name, nvl(:CONSTANT_REGEX, '^co_.*'), 'i') then
                         'OK'
                      else
                         'Constant does not match regex "'
                         || nvl(:CONSTANT_REGEX, '^co_.*')
                         || '".'
                   end
                   -- subtypes
                when usage = 'DECLARATION'
                   and type = 'SUBTYPE'
                then
                   case
                      when regexp_like(name, nvl(:SUBTYPE_REGEX, '.*_type$'), 'i') then
                         'OK'
                      else
                         'Subtype does not match regex "'
                         || nvl(:SUBTYPE_REGEX, '.*_type$')
                         || '".'
                   end
             end as message,
             case
                when usage = 'REFERENCE' then
                   parent_line
                else
                   line
             end as line,
             case
                when usage = 'REFERENCE' then
                   parent_col
                else
                   col
             end as col,
             text
        from prepared
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       message as "Message",
       line as "Line",
       col as "Col",
       text as "Text"
  from checked
 where message != 'OK'
 order by owner, object_type, object_name, line, col
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="GLOBAL_VARIABLE_REGEX">
					<prompt><![CDATA[Global variable regex]]></prompt>
					<tooltip><![CDATA[GLOBAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^g_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_RECORD_VARIABLE_REGEX">
					<prompt><![CDATA[Local record variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_RECORD_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^r_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_ARRAY_VARIABLE_REGEX">
					<prompt><![CDATA[Local array/table variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_ARRAY_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^t_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_OBJECT_VARIABLE_REGEX">
					<prompt><![CDATA[Local object variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_OBJECT_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^o_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_VARIABLE_REGEX">
					<prompt><![CDATA[Local variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^(l|c)_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_REGEX">
					<prompt><![CDATA[Cursor regex]]></prompt>
					<tooltip><![CDATA[CURSOR_REGEX]]></tooltip>
					<value><![CDATA[^c_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_PARAMETER_REGEX">
					<prompt><![CDATA[Cursor parameter regex]]></prompt>
					<tooltip><![CDATA[CURSOR_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^p_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_PARAMETER_REGEX">
					<prompt><![CDATA[IN parameter regex]]></prompt>
					<tooltip><![CDATA[IN_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^in_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="OUT_PARAMETER_REGEX">
					<prompt><![CDATA[OUT parameter regex]]></prompt>
					<tooltip><![CDATA[OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^out_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_OUT_PARAMETER_REGEX">
					<prompt><![CDATA[IN OUT_parameter regex]]></prompt>
					<tooltip><![CDATA[IN_OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^io_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="RECORD_REGEX">
					<prompt><![CDATA[Record regex]]></prompt>
					<tooltip><![CDATA[RECORD_REGEX]]></tooltip>
					<value><![CDATA[^r_.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="ARRAY_REGEX">
					<prompt><![CDATA[Array/table regex]]></prompt>
					<tooltip><![CDATA[ARRAY_REGEX]]></tooltip>
					<value><![CDATA[^t_.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="EXCEPTION_REGEX">
					<prompt><![CDATA[Exception regex]]></prompt>
					<tooltip><![CDATA[EXCEPTION_REGEX]]></tooltip>
					<value><![CDATA[^e_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CONSTANT_REGEX">
					<prompt><![CDATA[Constant regex]]></prompt>
					<tooltip><![CDATA[CONSTANT_REGEX]]></tooltip>
					<value><![CDATA[^co_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SUBTYPE_REGEX">
					<prompt><![CDATA[Subtype regex]]></prompt>
					<tooltip><![CDATA[SUBTYPE_REGEX]]></tooltip>
					<value><![CDATA[.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
</folder>
</displays>