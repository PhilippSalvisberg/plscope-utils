<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[plscope-utils Reports]]></name>
	<tooltip><![CDATA[PL/Scope reports]]></tooltip>
	<description><![CDATA[PL/Scope reports provided by plscope-utils, see https://github.com/PhilippSalvisberg/plscope-utils ]]></description>
		<display id="1dc49f53-015d-1000-8001-c0a8011251fe" type="" style="Table" enable="true">
		<name><![CDATA[Duplicate SQL Statements]]></name>
		<description><![CDATA[Reports duplicate static SQL statements within packages, procedures, functions, triggers and types. ]]></description>
		<tooltip><![CDATA[Reports duplicate static SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   plscope_statements as (
      select owner,
             signature,
             type,
             object_name,
             object_type,
             usage_id,
             line,
             col,
             usage_context_id,
             sql_id,
             case
                when (count(sql_id) over (partition by sql_id)) > 1 then
                   'YES'
                else
                   'NO'
             end as is_duplicate,
             has_hint,
             has_into_bulk,
             has_into_returning,
             has_into_record,
             has_current_of,
             has_for_update,
             has_in_binds,
             text,
             full_text,
             origin_con_id
        from sys.all_statements stmt -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       type as "Type",
       line as "Line",
       col as "Col",
       sql_id as "SQL_ID",
       full_text as "Text"
  from plscope_statements
 where is_duplicate = 'YES'
 order by owner, object_type, object_name, sql_id, line, col
]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					
					null															</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27802dea-015d-1000-8001-c0a80106a1a4" type="" style="Table" enable="true">
		<name><![CDATA[UDF Calls in SQL Statements]]></name>
		<description><![CDATA[Reports static SELECT, INSERT, UPDATE, DELETE and MERGE statements within packages, procedures, functions, triggers and types using user-defined function calls.]]></description>
		<tooltip><![CDATA[Reports user-defined function calls in SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
   with
      -- database source filtered by user
      src as (
         select /*+ materialize */
                owner,
                type,
                name,
                line,
                text
           from sys.all_source -- NOSONAR: avoid public synonym
          where owner like nvl(:OBJECT_OWNER, user)
      ),
      -- PL/SQL identifiers filtered by user
      pls_ids as (
         select /*+ materialize */
                owner,
                name,
                signature,
                type,
                object_name,
                object_type,
                usage,
                usage_id,
                line,
                col,
                usage_context_id,
                origin_con_id
           from sys.all_identifiers -- NOSONAR: avoid public synonym
          where owner like nvl(:OBJECT_OWNER, user)
      ),
      -- SQL identifiers filtered by user
      sql_ids as (
         select /*+ materialize */
                owner,
                nvl(sql_id, type) as name,
                signature,
                type,
                object_name,
                object_type,
                nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
                usage_id,
                line,
                col,
                usage_context_id,
                origin_con_id
           from sys.all_statements -- NOSONAR: avoid public synonym
          where owner like nvl(:OBJECT_OWNER, user)
      ),
      -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
      fids as (
         select 'NO' as is_sql_stmt,
                pls_ids.owner,
                pls_ids.name,
                pls_ids.signature,
                pls_ids.type,
                pls_ids.object_name,
                pls_ids.object_type,
                pls_ids.usage,
                pls_ids.usage_id,
                pls_ids.line,
                pls_ids.col,
                pls_ids.usage_context_id,
                nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
                pls_ids.origin_con_id
           from pls_ids
           left join pls_ids sig
             on sig.owner = pls_ids.owner
            and sig.object_type = 'PACKAGE'
            and sig.object_name = pls_ids.object_name
            and sig.usage = 'DECLARATION'
            and sig.signature = pls_ids.signature
         union all
         select 'YES' as is_sql_stmt,
                owner,
                name,
                signature,
                type,
                object_name,
                object_type,
                usage,
                usage_id,
                line,
                col,
                usage_context_id,
                null as procedure_scope,
                origin_con_id
           from sql_ids
      ),
      -- add column sane_fk to list of identifiers
      base_ids as (
         select fids.is_sql_stmt,
                fids.owner,
                fids.name,
                fids.signature,
                fids.type,
                fids.object_name,
                fids.object_type,
                fids.usage,
                fids.usage_id,
                case
                   when parent.usage_id is not null
                      or fids.usage_context_id = 0
                   then
                      'YES'
                   else
                      'NO'
                end as sane_fk,
                fids.line,
                fids.col,
                fids.usage_context_id,
                fids.procedure_scope,
                fids.origin_con_id
           from fids
           left join fids parent
             on parent.owner = fids.owner
            and parent.object_type = fids.object_type
            and parent.object_name = fids.object_name
            and parent.usage_id = fids.usage_context_id
      ),
      -- add columns usage_context_id, is_fixed_context_id to list of identifiers
      ids as (
         select is_sql_stmt,
                owner,
                name,
                signature,
                type,
                object_name,
                object_type,
                usage,
                usage_id,
                line,
                col,
                case
                   when sane_fk = 'YES' then
                      usage_context_id
                   else
                      last_value(case
                                    when sane_fk = 'YES' then
                                       usage_id
                                 end) ignore nulls over (
                         partition by owner, object_name, object_type
                         order by line, col, usage_id
                         rows between unbounded preceding and 1 preceding
                      )
                end as usage_context_id,        -- fix broken hierarchies
                case
                   when sane_fk = 'NO' then
                      cast('YES' as varchar2(3 char))
                end as is_fixed_context_id,     -- indicator of fixed hierarchies
                procedure_scope,
                origin_con_id
           from base_ids
      ),
      -- recursive with clause to extend the list of identifiers with the columns
      -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
      -- parent_statement_type, parent_statement_signature, parent_statement_path_len,
      -- is_def_child_of_decl
      tree (
         owner,
         object_type,
         object_name,
         line,
         col,
         procedure_name,
         procedure_scope,
         name,
         name_path,
         path_len,
         type,
         usage,
         signature,
         usage_id,
         usage_context_id,
         is_fixed_context_id,
         procedure_signature,
         is_sql_stmt,
         parent_statement_type,
         parent_statement_signature,
         parent_statement_path_len,
         is_def_child_of_decl,
         origin_con_id
      ) as (
         select owner,
                object_type,
                object_name,
                line,
                col,
                case
                   when object_type in ('PROCEDURE', 'FUNCTION') then
                      name
                end as procedure_name,
                case
                   when object_type in ('PROCEDURE', 'FUNCTION') then
                      cast('PUBLIC' as varchar2(7 char))
                end as procedure_scope,
                name,
                '/' || name as name_path,
                1 as path_len,
                type,
                usage,
                signature,
                usage_id,
                usage_context_id,
                is_fixed_context_id,
                case
                   when object_type in ('PROCEDURE', 'FUNCTION') then
                      signature
                end as procedure_signature,
                is_sql_stmt,
                cast(null as varchar2(18 char)) as parent_statement_type,
                cast(null as varchar2(32 char)) as parent_statement_signature,
                cast(null as number) as parent_statement_path_len,
                cast(null as varchar2(3 char)) as is_def_child_of_decl,
                origin_con_id
           from ids
          where usage_context_id = 0  -- top-level identifiers
         union all
         select ids.owner,
                ids.object_type,
                ids.object_name,
                ids.line,
                ids.col,
                case
                   when tree.procedure_name is not null then
                      tree.procedure_name
                   when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                      and ids.type in ('FUNCTION', 'PROCEDURE')
                      and ids.usage in ('DEFINITION', 'DECLARATION')
                      and ids.usage_context_id = 1
                   then
                      ids.name
                end as procedure_name,
                case
                   when tree.procedure_scope is not null then
                      tree.procedure_scope
                   when ids.object_type = 'PACKAGE'
                      and ids.type in ('FUNCTION', 'PROCEDURE')
                      and ids.usage = 'DECLARATION'
                      and ids.usage_context_id = 1
                   then
                      'PUBLIC'
                   when ids.object_type = 'PACKAGE BODY'
                      and ids.type in ('FUNCTION', 'PROCEDURE')
                      and ids.usage in ('DEFINITION', 'DECLARATION')
                      and ids.usage_context_id = 1
                   then
                      case ids.procedure_scope
                         when 'PUBLIC' then
                            'PUBLIC'
                         else
                            'PRIVATE'
                      end
                end as procedure_scope,
                ids.name,
                case
                   when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                      tree.name_path
                      || '/'
                      || ids.name
                   else
                      -- prevent name_path from overflowing: keep the first 3 elements, then
                      -- remove enough elements to accomodate "..." + "/" + the tail end
                      regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                      || '...'
                      || regexp_replace(
                         substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                            + lengthb('.../') + lengthb(ids.name)),
                         '^[^/]*')
                      || '/'
                      || ids.name
                end as name_path,
                tree.path_len + 1 as path_len,
                ids.type,
                ids.usage,
                ids.signature,
                ids.usage_id,
                ids.usage_context_id,
                ids.is_fixed_context_id,
                case
                   when tree.procedure_signature is not null then
                      tree.procedure_signature
                   when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                      and ids.type in ('FUNCTION', 'PROCEDURE')
                      and ids.usage in ('DEFINITION', 'DECLARATION')
                      and ids.usage_context_id = 1
                   then
                      ids.signature
                end as procedure_signature,
                ids.is_sql_stmt,
                case
                   when tree.is_sql_stmt = 'YES' then
                      tree.type
                   else
                      tree.parent_statement_type
                end as parent_statement_type,
                case
                   when tree.is_sql_stmt = 'YES' then
                      tree.signature
                   else
                      tree.parent_statement_signature
                end as parent_statement_signature,
                case
                   when tree.is_sql_stmt = 'YES' then
                      tree.path_len
                   else
                      tree.parent_statement_path_len
                end as parent_statement_path_len,
                case
                   when ids.type in ('PROCEDURE', 'FUNCTION')
                      and ids.usage = 'DEFINITION'
                   then
                      case
                         when tree.usage = 'DECLARATION'
                            and ids.signature = tree.signature
                         then
                            'YES'
                         else
                            'NO'
                      end
                end as is_def_child_of_decl,
                ids.origin_con_id
           from tree
           join ids
             on tree.owner = ids.owner
            and tree.object_type = ids.object_type
            and tree.object_name = ids.object_name
            and tree.usage_id = ids.usage_context_id
      ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
      -- add the columns name_usage, is_new_proc to the list of identifiers
      tree_plus as (
         select tree.*,                                                 -- @formatter:off
                case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage,                                      -- @formatter:on
                case
                   when type in ('PROCEDURE', 'FUNCTION')
                      and usage = 'DEFINITION'
                      and nvl(
                         lag(
                            procedure_signature,
                            case is_def_child_of_decl
                               when 'YES' then
                                  2
                               else
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_type, tree.object_name
                            order by usage_id asc
                         ),
                         '----'
                      ) != procedure_signature
                   then
                      'YES'
                end as is_new_proc
           from tree
      ),
   plscope_identifiers as (
   -- add indent to column name_usage, fix column usage and adds the columns text, is_used,
   -- proc_ends_before_line, proc_ends_before_col, ref_line, ref_col to the list of identifiers
   select tree.owner,
          tree.object_type,
          tree.object_name,
          tree.line,
          tree.col,
          tree.procedure_name,
          tree.procedure_scope,
          cast(
             -- left indent name_usage according to path_len, wrapping to the left
             -- if necessary so as not to exceed a limit of 250 characters
             case
                when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                   lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                else
                   substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                      - length(tree.name_usage))
                   || lpad(' ', 250 - length(tree.name_usage))
                   || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
             end
             as varchar2(250 char)
          ) as name_usage,
          tree.name,
          tree.name_path,
          tree.path_len,
          tree.type,
          case
             -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
             when tree.usage in ('SQL_ID', 'SQL_STMT') then
                'EXECUTE'
             else
                tree.usage
          end as usage,
          refs.owner as ref_owner,                 -- decl_owner
          refs.object_type as ref_object_type,     -- decl_object_type
          refs.object_name as ref_object_name,     -- decl_object_name
          regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
          tree.parent_statement_type,
          tree.parent_statement_signature,
          tree.parent_statement_path_len,
          case
             -- wrong result, if used in statements which do not register usage,
             -- such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE.
             -- Bug 26351814.
             when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                and tree.usage = 'DECLARATION'
                and tree.type not in ('LABEL')
             then
                case
                   when count(
                         case
                            when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                               or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                  and tree.usage = 'ASSIGNMENT')
                            then
                               1
                         end
                      ) over (
                         partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                      ) = 0
                   then
                      'NO'
                   else
                      'YES'
                end
          end as is_used,
          tree.signature,
          tree.usage_id,
          tree.usage_context_id,
          tree.is_fixed_context_id,
          tree.procedure_signature,
          --tree.is_def_child_of_decl,    --uncomment if needed for debugging
          --tree.is_new_proc,             --uncomment if needed for debugging
          case
             when tree.is_new_proc = 'YES' then
                coalesce(
                   first_value(
                      case
                         when tree.is_new_proc = 'YES'
                            or tree.usage_context_id = 1
                         then
                            tree.line
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_type, tree.object_name
                      order by tree.usage_id
                      rows between 1 following and unbounded following
                   ),
                   max(tree.line) over (
                         partition by tree.owner, tree.object_type, tree.object_name
                   ) + 1
                )
          end as proc_ends_before_line,
          case
             when tree.is_new_proc = 'YES' then
                nvl(
                   first_value(
                      case
                         when tree.is_new_proc = 'YES'
                            or tree.usage_context_id = 1
                         then
                            tree.col
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_type, tree.object_name
                      order by tree.usage_id
                      rows between 1 following and unbounded following
                   ),
                   1
                )
          end as proc_ends_before_col,
          refs.line as ref_line,         -- decl_line
          refs.col as ref_col,           -- decl_col
          tree.origin_con_id
     from tree_plus tree
     left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
       on refs.signature = tree.signature
      and refs.usage = 'DECLARATION'
     left join src
       on src.owner = tree.owner
      and src.type = tree.object_type
      and src.name = tree.object_name
      and src.line = tree.line
      )
-- the with clause is based on relational view "plscope_identifiers" with the following minimal changes:
--     - filter on "owner like nvl(:OBJECT_OWNER, user)" instead of plscope context variables
--     - replace "dba_" with "sys._all_" to make the query work with and without dba rights
-- producing a list of SQL statements with user-defined function calls
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       parent_statement_type as "Statement type",
       name as "Function name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where parent_statement_type in ('SELECT', 'INSERT', 'UPDATE', 'DETETE', 'MERGE')
   and type = 'FUNCTION'
   and usage = 'CALL'
   -- ensure function call is part of the parent statement
   and (parent_statement_path_len >= path_len - 2)
   -- do not report function calls from standard package such as USER, REPLACE, SUBSTR, etc.
   and not (ref_owner = 'SYS' and ref_object_type = 'PACKAGE' and ref_object_name = 'STANDARD')
 order by owner, object_type, object_name, line, col
 ]]>
            </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27d1dbe9-015d-1000-8001-c0a801060752" type="" style="Table" enable="true">
		<name><![CDATA[CRUD Operations]]></name>
		<description><![CDATA[Reports static usages of tables/views/synonyms within packages, procedures, functions, triggers and types. Reports number of SELECT, INSERT, UPDATE, DELETE, MERGE, REFERENCE usages per PL/SQL unit ]]></description>
		<tooltip><![CDATA[Number of select, insert, update, delete, merge, reference usages per PL/SQL unit.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   -- database source filtered by user
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- PL/SQL identifiers filtered by user
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- SQL identifiers filtered by user
   sql_ids as (
      select /*+ materialize */
             owner,
             nvl(sql_id, type) as name,
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_statements -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
      union all
      select 'YES' as is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             null as procedure_scope,
             origin_con_id
        from sql_ids
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the name_usage column to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage                                    -- @formatter:on
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage, and add the text, ref_line,
      -- and ref_col columns to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   ),
   identifiers as ( 
      select /*+ materialize */
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.procedure_name,
             ids.usage,
             ids.line,
             ids.col,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.parent_statement_signature
        from plscope_identifiers ids
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
   ),
   -- direct and indirect dependencies; path_len = 0 for direct dependencies, 
   -- otherwise the length of the dependency chain, i.e. level - 1; cycles are
   -- possible here (with help from synonyms) so we need to detect them
   dep_chains (
      owner,
      type,
      name,
      ref_owner,
      ref_type,
      ref_name,
      path_len
   ) as (
      -- direct dependencies
      select distinct
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             0
        from identifiers ids
       where ids.ref_object_type in ('VIEW', 'TABLE', 'SYNONYM')
       union all
      -- indirect dependencies
      select /*+ no_merge(dep) */ 
             par.owner,
             par.type,
             par.name,
             dep.referenced_owner,
             dep.referenced_type,
             dep.referenced_name,
             par.path_len + 1
        from dep_chains par
        join sys.all_dependencies dep  -- NOSONAR: avoid public synonym
          on par.ref_owner = dep.owner
         and par.ref_type = dep.type
         and par.ref_name = dep.name
       where par.ref_type <> 'VIEW'    -- don't resolve table usages in views
         and dep.referenced_type in (  -- list of referenced types of interest
                'VIEW', 
                'TABLE', 
                'SYNONYM',
                'MATERIALIZED VIEW'    -- does MATERIALIZED VIEW belong here?
             )
   )
   cycle ref_owner, ref_type, ref_name set is_cycle to 'Y' default 'N',
   -- eliminate duplicate dependencies, keeping the minimum path_len; add the 
   -- base_object_type column, which is the type of the first object (if any)
   -- which is not a synonym, in case we're going down a chain of synonyms;
   -- the is_base_object flag is set to 'YES' for that object, otherwise null
   dep_trans_closure as (
      select owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name,
             min(path_len)  as path_len,
             nullif(                            -- @formatter:off
                min(ref_type)
                keep (
                   dense_rank first
                   order by 
                      case
                         when ref_type = 'SYNONYM' then
                            null
                         else
                            min(path_len)
                      end asc nulls last,
                      min(path_len)
                )
                over (
                   partition by owner, type, name
                ),
                'SYNONYM'
             )  as base_obj_type,               -- @formatter:on
             case                               -- @formatter:off
                -- remark: disregarding the case when there are only SYNONYMs in the 
                -- dependency chain: such chains are filtered out in tab_usage subquery
                when min(path_len) = min(min(path_len))
                      keep (
                         dense_rank first
                         order by 
                            case
                               when ref_type = 'SYNONYM' then
                                  null
                               else
                                  min(path_len)
                            end asc nulls last,
                            min(path_len)
                      )
                      over (
                         partition by owner, type, name
                      ) 
                then
                   cast('YES' as varchar2(3 char))
             end  as is_base_object             -- @formatter:on
        from dep_chains
       group by owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name      
   ),
   plscope_tab_usage as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             dep.ref_owner,
             dep.ref_type  as ref_object_type,
             dep.ref_name  as ref_object_name,
             case
                when dep.path_len = 0 then
                   'YES'
                else
                   'NO'
             end as direct_dependency,
             dep.is_base_object
        from identifiers ids
        join dep_trans_closure dep
          on dep.owner = ids.ref_owner
         and dep.type = ids.ref_object_type
         and dep.name = ids.ref_object_name
         and dep.base_obj_type is not null  -- drop syn. refs not leading to tables/views
        left join sys.all_statements refs   -- NOSONAR: avoid public synonym
          on refs.signature = ids.parent_statement_signature   
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(min(line), 'FM0000009')
             || ':'
             || to_char(1, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       ref_owner as "Ref Owner",
       ref_object_type "Ref object type",
       ref_object_name "Ref object name",
       sum(case
              when operation = 'SELECT' then
                 1
              else
                 0
           end) as "Select",
       sum(case
              when operation = 'INSERT' then
                 1
              else
                 0
           end) as "Insert",
       sum(case
              when operation = 'UPDATE' then
                 1
              else
                 0
           end) as "Update",
       sum(case
              when operation = 'DELETE' then
                 1
              else
                 0
           end) as "Delete",
       sum(case
              when operation = 'MERGE' then
                 1
              else
                 0
           end) as "Merge",
       sum(case
              when operation = 'REFERENCE' then
                 1
              else
                 0
           end) as "Reference"
  from plscope_tab_usage
 where operation in ('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'MERGE', 'REFERENCE')
   and is_base_object = 'YES'
 group by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name
 order by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name
]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="2e3cb6a6-015d-1000-8001-c0a801126c36" type="" style="Table" enable="true">
		<name><![CDATA[Unused Local Identifiers]]></name>
		<description><![CDATA[Reports locally declared identifiers in within packages, procedures, functions, triggers and types which are not referenced.]]></description>
		<tooltip><![CDATA[Reports unreferenced locally defined identifiers]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[
with
   -- database source filtered by user
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- PL/SQL identifiers filtered by user
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- SQL identifiers filtered by user
   sql_ids as (
      select /*+ materialize */
             owner,
             nvl(sql_id, type) as name,
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_statements -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
      union all
      select 'YES' as is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             null as procedure_scope,
             origin_con_id
        from sql_ids
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len,
   -- is_def_child_of_decl
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      is_def_child_of_decl,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             cast(null as varchar2(3 char)) as is_def_child_of_decl,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             case
                when ids.type in ('PROCEDURE', 'FUNCTION')
                   and ids.usage = 'DEFINITION'
                then
                   case
                      when tree.usage = 'DECLARATION'
                         and ids.signature = tree.signature
                      then
                         'YES'
                      else
                         'NO'
                   end
             end as is_def_child_of_decl,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the columns name_usage, is_new_proc to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage,                                      -- @formatter:on
             case
                when type in ('PROCEDURE', 'FUNCTION')
                   and usage = 'DEFINITION'
                   and nvl(
                      lag(
                         procedure_signature,
                         case is_def_child_of_decl
                            when 'YES' then
                               2
                            else
                               1
                         end
                      ) over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by usage_id asc
                      ),
                      '----'
                   ) != procedure_signature
                then
                   'YES'
             end as is_new_proc
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage and adds the columns text, is_used,
      -- proc_ends_before_line, proc_ends_before_col, ref_line, ref_col to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                   -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             case
                   -- wrong result, if used in statements which do not register usage,
                   -- such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE.
                   -- Bug 26351814.
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             --tree.is_def_child_of_decl,    --uncomment if needed for debugging
             --tree.is_new_proc,             --uncomment if needed for debugging
             case
                when tree.is_new_proc = 'YES' then
                   coalesce(
                      first_value(
                         case
                            when tree.is_new_proc = 'YES'
                               or tree.usage_context_id = 1
                            then
                               tree.line
                         end
                      ) ignore nulls over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by tree.usage_id
                         rows between 1 following and unbounded following
                      ),
                      max(tree.line) over (
                            partition by tree.owner, tree.object_type, tree.object_name
                      ) + 1
                   )
             end as proc_ends_before_line,
             case
                when tree.is_new_proc = 'YES' then
                   nvl(
                      first_value(
                         case
                            when tree.is_new_proc = 'YES'
                               or tree.usage_context_id = 1
                            then
                               tree.col
                         end
                      ) ignore nulls over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by tree.usage_id
                         rows between 1 following and unbounded following
                      ),
                      1
                   )
             end as proc_ends_before_col,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
-- the with clause is based on relational view "plscope_identifiers" with the following minimal changes:
--     - filter on "owner like nvl(:OBJECT_OWNER, user)" instead of plscope context variables
--     - replace "dba_" with "sys._all_" to make the query work with and without dba rights
-- producing a list of unused local identifiers
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where usage = 'DECLARATION'
   and is_used = 'NO'
 order by owner, object_type, object_name, line, col
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query minversion="11.1">
			<sql><![CDATA[
with
   -- database source filtered by user
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- PL/SQL identifiers filtered by user
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             0 as origin_con_id
        from sys.all_identifiers
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
       where pls_ids.owner like nvl(:OBJECT_OWNER, user)
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len,
   -- is_def_child_of_decl
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      is_def_child_of_decl,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18)) as parent_statement_type,
             cast(null as varchar2(32)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             cast(null as varchar2(3)) as is_def_child_of_decl,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             case
                when ids.type in ('PROCEDURE', 'FUNCTION')
                   and ids.usage = 'DEFINITION'
                then
                   case
                      when tree.usage = 'DECLARATION'
                         and ids.signature = tree.signature
                      then
                         'YES'
                      else
                         'NO'
                   end
             end as is_def_child_of_decl,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the columns name_usage, is_new_proc to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                when tree.usage = 'SQL_ID' then
                   tree.type || ' statement (sql_id: ' || tree.name || ')'
                when tree.usage = 'SQL_STMT' then
                   tree.type || ' statement'
                else
                   tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
             end as name_usage,                                      -- @formatter:on
             case
                when type in ('PROCEDURE', 'FUNCTION')
                   and usage = 'DEFINITION'
                   and nvl(
                      lag(
                         procedure_signature,
                         case is_def_child_of_decl
                            when 'YES' then
                               2
                            else
                               1
                         end
                      ) over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by usage_id asc
                      ),
                      '----'
                   ) != procedure_signature
                then
                   'YES'
             end as is_new_proc
        from tree
   ),
   -- add indent to column name_usage, fix column usage and adds the columns text, is_used,
   -- proc_ends_before_line, proc_ends_before_col, ref_line, ref_col to the list of identifiers
   plscope_identifiers as (
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                   -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             case
                   -- wrong result, if used in statements which do not register usage,
                   -- such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE.
                   -- Bug 26351814.
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             --tree.is_def_child_of_decl,    --uncomment if needed for debugging
             --tree.is_new_proc,             --uncomment if needed for debugging
             case
                when tree.is_new_proc = 'YES' then
                   coalesce(
                      first_value(
                         case
                            when tree.is_new_proc = 'YES'
                               or tree.usage_context_id = 1
                            then
                               tree.line
                         end
                      ) ignore nulls over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by tree.usage_id
                         rows between 1 following and unbounded following
                      ),
                      max(tree.line) over (
                            partition by tree.owner, tree.object_type, tree.object_name
                      ) + 1
                   )
             end as proc_ends_before_line,
             case
                when tree.is_new_proc = 'YES' then
                   nvl(
                      first_value(
                         case
                            when tree.is_new_proc = 'YES'
                               or tree.usage_context_id = 1
                            then
                               tree.col
                         end
                      ) ignore nulls over (
                         partition by tree.owner, tree.object_type, tree.object_name
                         order by tree.usage_id
                         rows between 1 following and unbounded following
                      ),
                      1
                   )
             end as proc_ends_before_col,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join pls_ids refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
-- the with clause is based on relational view "plscope_identifiers" with the following minimal changes:
--     - filter on "owner like nvl(:OBJECT_OWNER, user)" instead of plscope context variables
--     - replace "dba_" with "sys._all_" to make the query work with and without dba rights
--     - named query fids is based on PL/SQL identifiers only (no SQL identifiers available in 11.1)
--     - origin_con_id is set to zero (no multi-tenant option available in 11.1)
-- producing a list of unused local identifiers
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_identifiers
 where usage = 'DECLARATION'
   and is_used = 'NO'
 order by owner, object_type, object_name, line, col
 ]]>
			</sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="9f38924a-015d-1000-8001-c0a80112c4cd" type="" style="Table" enable="true">
		<name><![CDATA[PL/SQL Naming Conventions]]></name>
		<description><![CDATA[Check PL/SQL identifiers based on the Trivadis PL/SQL & SQL Coding Guidelines V3.2]]></description>
		<tooltip><![CDATA[Reports PL/SQL identifiers violationg naming conventions]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="11.1">
			<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   ids as (
      select owner,
             name,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where owner like nvl(:OBJECT_OWNER, user)
   ),
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      name,
      name_path,
      path_len,
      type,
      type_path,
      parent_usage,
      parent_type,
      parent_name,
      parent_line,
      parent_col,
      usage,
      usage_id,
      usage_context_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             '/' || type as type_path,
             null as parent_usage,
             null as parent_type,
             null as parent_name,
             null as parent_line,
             null as parent_col,
             usage,
             usage_id,
             usage_context_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             case
                when lengthb(tree.type_path) + lengthb('/') + lengthb(ids.type) <= 4000 then
                   tree.type_path
                   || '/'
                   || ids.type
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.type_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.type_path, instr(tree.type_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.type)),
                      '^[^/]*')
                   || '/'
                   || ids.type
             end as type_path,
             tree.usage as parent_usage,
             tree.type as parent_type,
             tree.name as parent_name,
             tree.line as parent_line,
             tree.col as parent_col,
             ids.usage,
             ids.usage_id,
             ids.usage_context_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   prepared as (
      select tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             regexp_replace(src.text, chr(10) || '+$', null) as text, -- remove trailing new line character
             tree.usage,
             tree.type,
             tree.name,
             tree.line,
             tree.col,
             tree.type_path,
             tree.parent_usage,
             tree.parent_type,
             tree.parent_name,
             tree.parent_line,
             tree.parent_col
        from tree
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
       where tree.object_type in ('FUNCTION', 'PROCEDURE', 'TRIGGER', 'PACKAGE', 'PACKAGE BODY', 'TYPE', 'TYPE BODY')
   ),
   checked as (
      select owner,
             object_type,
             object_name,
             procedure_name,
             case
                when usage = 'REFERENCE' then
                   parent_usage
                else
                   usage
             end as usage,
             case
                when usage = 'REFERENCE' then
                   parent_type
                else
                   type
             end as type,
             case
                when usage = 'REFERENCE' then
                   parent_name
                else
                   name
             end as name,
             case
                   -- global variables (all types)
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and regexp_like(type_path, '/PACKAGE/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*'), 'i') then
                         'OK'
                      else
                         'Global variable does not match regex "'
                         || nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*')
                         || '".'
                   end
                   -- local record variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and (type = 'RECORD' or regexp_like(text, '.*%\s*rowtype.*', 'i'))
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD ITERATOR|RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*'), 'i') then
                         'OK'
                      else
                         'Local record variable does not match regex "'
                         || nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*')
                         || '".'
                   end
                   -- local array/table variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and type in ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD ITERATOR|RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*'), 'i') then
                         'OK'
                      else
                         'Local array/table variable does not match regex "'
                         || nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*')
                         || '".'
                   end
                   -- local object variables
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and type = 'OBJECT'
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD ITERATOR|RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*'), 'i') then
                         'OK'
                      else
                         'Local object variable does not match regex "'
                         || nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*')
                         || '".'
                   end
                   -- local variables for other types
                when parent_usage = 'DECLARATION'
                   and parent_type = 'VARIABLE'
                   and usage = 'REFERENCE'
                   and object_type != 'TYPE'
                   and not regexp_like(type_path, '/(RECORD ITERATOR|RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                then
                   case
                      when regexp_like(parent_name, nvl(:LOCAL_VARIABLE_REGEX, '^(l|c)_.*'), 'i') then
                         'OK'
                      else
                         'Local variable does not match regex "'
                         || nvl(:LOCAL_VARIABLE_REGEX, '^(l|c)_.*')
                         || '".'
                   end
                   -- cursors
                when usage = 'DECLARATION'
                   and type = 'CURSOR'
                then
                   case
                      when regexp_like(name, nvl(:CURSOR_REGEX, '^c_.*'), 'i') then
                         'OK'
                      else
                         'Cursor does not match regex "'
                         || nvl(:CURSOR_REGEX, '^c_.*')
                         || '".'
                   end
                   -- cursor parameters
                when parent_usage = 'DECLARATION'
                   and parent_type = 'CURSOR'
                   and usage = 'DECLARATION'
                   and type like 'FORMAL%'
                then
                   case
                      when regexp_like(name, nvl(:CURSOR_PARAMETER_REGEX, '^p_.*'), 'i') then
                         'OK'
                      else
                         'Cursor parameter does not match regex "'
                         || nvl(:CURSOR_PARAMETER_REGEX, '^p_.*')
                         || '".'
                   end
                   -- IN parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL IN'
                then
                   case
                      when regexp_like(name, nvl(:IN_PARAMETER_REGEX, '^in_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'IN parameter does not match regex "'
                         || nvl(:IN_PARAMETER_REGEX, '^in_.*')
                         || '".'
                   end
                   -- OUT parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL OUT'
                then
                   case
                      when regexp_like(name, nvl(:OUT_PARAMETER_REGEX, '^out_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'OUT parameter does not match regex "'
                         || nvl(:OUT_PARAMETER_REGEX, '^out_.*')
                         || '".'
                   end
                   -- IN OUT parameters
                when usage = 'DECLARATION'
                   and type = 'FORMAL IN OUT'
                then
                   case
                      when regexp_like(name, nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*'), 'i')
                         or (object_type in ('TYPE', 'TYPE BODY') and name = 'SELF')
                      then
                         'OK'
                      else
                         'IN OUT parameter does not match regex "'
                         || nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*')
                         || '".'
                   end
                   -- records
                when usage = 'DECLARATION'
                   and type = 'RECORD'
                then
                   case
                      when regexp_like(name, nvl(:RECORD_REGEX, '^r_.*_type$'), 'i') then
                         'OK'
                      else
                         'Record does not match regex "'
                         || nvl(:RECORD_REGEX, '^r_.*_type$')
                         || '".'
                   end
                   -- arrays/tables
                when usage = 'DECLARATION'
                   and type in ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                then
                   case
                      when regexp_like(name, nvl(:ARRAY_REGEX, '^t_.*_type$|^.*_ct$'), 'i') then
                         'OK'
                      else
                         'Array/table does not match regex "'
                         || nvl(:ARRAY_REGEX, '^t_.*_type$')
                         || '".'
                   end
                   -- exceptions
                when usage = 'DECLARATION'
                   and type = 'EXCEPTION'
                then
                   case
                      when regexp_like(name, nvl(:EXCEPTION_REGEX, '^e_.*'), 'i') then
                         'OK'
                      else
                         'Exception does not match regex "'
                         || nvl(:EXCEPTION_REGEX, '^e_.*')
                         || '".'
                   end
                   -- constants
                when usage = 'DECLARATION'
                   and type = 'CONSTANT'
                then
                   case
                      when regexp_like(name, nvl(:CONSTANT_REGEX, '^co_.*'), 'i') then
                         'OK'
                      else
                         'Constant does not match regex "'
                         || nvl(:CONSTANT_REGEX, '^co_.*')
                         || '".'
                   end
                   -- subtypes
                when usage = 'DECLARATION'
                   and type = 'SUBTYPE'
                then
                   case
                      when regexp_like(name, nvl(:SUBTYPE_REGEX, '.*_type$'), 'i') then
                         'OK'
                      else
                         'Subtype does not match regex "'
                         || nvl(:SUBTYPE_REGEX, '.*_type$')
                         || '".'
                   end
             end as message,
             case
                when usage = 'REFERENCE' then
                   parent_line
                else
                   line
             end as line,
             case
                when usage = 'REFERENCE' then
                   parent_col
                else
                   col
             end as col,
             text
        from prepared
   ),
   plscope_naming as (
      select owner,
             object_type,
             object_name,
             procedure_name,
             type,
             name,
             message,
             line,
             col,
             text
        from checked
       where message is not null
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       owner as "Owner",
       object_type as "Object type",
       object_name as "Object name",
       procedure_name as "Procedure name",
       type as "Type",
       name as "Name",
       message as "Message",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_naming
 where message != 'OK'
 order by owner, object_type, object_name, line, col
 ]]>
         </sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="GLOBAL_VARIABLE_REGEX">
					<prompt><![CDATA[Global variable regex]]></prompt>
					<tooltip><![CDATA[GLOBAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^g_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_RECORD_VARIABLE_REGEX">
					<prompt><![CDATA[Local record variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_RECORD_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^r_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_ARRAY_VARIABLE_REGEX">
					<prompt><![CDATA[Local array/table variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_ARRAY_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^t_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_OBJECT_VARIABLE_REGEX">
					<prompt><![CDATA[Local object variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_OBJECT_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^o_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_VARIABLE_REGEX">
					<prompt><![CDATA[Local variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^(l|c)_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_REGEX">
					<prompt><![CDATA[Cursor regex]]></prompt>
					<tooltip><![CDATA[CURSOR_REGEX]]></tooltip>
					<value><![CDATA[^c_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_PARAMETER_REGEX">
					<prompt><![CDATA[Cursor parameter regex]]></prompt>
					<tooltip><![CDATA[CURSOR_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^p_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_PARAMETER_REGEX">
					<prompt><![CDATA[IN parameter regex]]></prompt>
					<tooltip><![CDATA[IN_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^in_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="OUT_PARAMETER_REGEX">
					<prompt><![CDATA[OUT parameter regex]]></prompt>
					<tooltip><![CDATA[OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^out_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_OUT_PARAMETER_REGEX">
					<prompt><![CDATA[IN OUT_parameter regex]]></prompt>
					<tooltip><![CDATA[IN_OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^io_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="RECORD_REGEX">
					<prompt><![CDATA[Record regex]]></prompt>
					<tooltip><![CDATA[RECORD_REGEX]]></tooltip>
					<value><![CDATA[^r_.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="ARRAY_REGEX">
					<prompt><![CDATA[Array/table regex]]></prompt>
					<tooltip><![CDATA[ARRAY_REGEX]]></tooltip>
					<value><![CDATA[^t_.*_type$|^.*_ct$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="EXCEPTION_REGEX">
					<prompt><![CDATA[Exception regex]]></prompt>
					<tooltip><![CDATA[EXCEPTION_REGEX]]></tooltip>
					<value><![CDATA[^e_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CONSTANT_REGEX">
					<prompt><![CDATA[Constant regex]]></prompt>
					<tooltip><![CDATA[CONSTANT_REGEX]]></tooltip>
					<value><![CDATA[^co_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SUBTYPE_REGEX">
					<prompt><![CDATA[Subtype regex]]></prompt>
					<tooltip><![CDATA[SUBTYPE_REGEX]]></tooltip>
					<value><![CDATA[.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
</folder>
</displays>
