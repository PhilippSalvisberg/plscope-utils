<?xml version="1.0" encoding="UTF-8"?>
<displays>
	<!-- based on -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_identifiers.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_statements.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_tab_usage.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_col_usage.sql -->
	<!-- used sys.all_ instead of dba_ - SQL Developer uses dba_ views, if the the connected use has the privileges -->
	<!-- Use case sensitive result columns including spaces -->
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view">
		<name><![CDATA[Identifiers]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
         ' BODY')
         and object_name = :OBJECT_NAME
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the columns name_usage, is_new_proc to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage                                    -- @formatter:on
        from tree
   )
select case
          when tree.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || tree.owner
             || ':'
             || tree.object_type
             || ':'
             || tree.object_name
             || ':'
             || to_char(tree.line, 'FM0000009')
             || ':'
             || to_char(tree.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       cast(
          -- left indent name_usage according to path_len, wrapping to the left
          -- if necessary so as not to exceed a limit of 250 characters
          case
             when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
             else
                substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                   - length(tree.name_usage))
                || lpad(' ', 250 - length(tree.name_usage))
                || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
          end
          as varchar2(250)
       ) as "Name (Type, Usage)",
       tree.line as "Line",
       tree.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text", -- remove trailing new line character
       tree.name as "Name",
       tree.type as "Type",
       case
             -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
          when tree.usage in ('SQL_ID', 'SQL_STMT') then
             'EXECUTE'
          else
             tree.usage
       end as "Usage",
       case
          when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
             and tree.usage = 'DECLARATION'
             and tree.type not in ('LABEL')
          then
             case
                when count(
                      case
                         when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                            or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                               and tree.usage = 'ASSIGNMENT')
                         then
                            1
                      end
                   ) over (
                      partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                   ) = 0
                then
                   'NO'
                else
                   'YES'
             end
       end as "Used?"
  from tree_plus tree
  left join src
    on src.owner = tree.owner
   and src.type = tree.object_type
   and src.name = tree.object_name
   and src.line = tree.line
 order by length(tree.object_type), tree.line, tree.col, tree.path_len
]]>
            </sql>
			</query>
			<query minversion="11.1">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
       where (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
         ' BODY')
         and object_name = :OBJECT_NAME
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the columns name_usage, is_new_proc to the list of identifiers
   tree_plus as (
      select tree.*,
             tree.name
             || ' ('
             || lower(tree.type)
             || ' '
             || lower(tree.usage)
             || ')' as name_usage
        from tree
   )
select case
          when tree.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || tree.owner
             || ':'
             || tree.object_type
             || ':'
             || tree.object_name
             || ':'
             || to_char(tree.line, 'FM0000009')
             || ':'
             || to_char(tree.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       cast(
          -- left indent name_usage according to path_len, wrapping to the left
          -- if necessary so as not to exceed a limit of 250 characters
          case
             when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
             else
                substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                   - length(tree.name_usage))
                || lpad(' ', 250 - length(tree.name_usage))
                || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
          end
          as varchar2(250)
       ) as "Name (Type, Usage)",
       tree.line as "Line",
       tree.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text", -- remove trailing new line character
       tree.name as "Name",
       tree.type as "Type",
       tree.usage as "Usage",
       case
          when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
             and tree.usage = 'DECLARATION'
             and tree.type not in ('LABEL')
          then
             case
                when count(
                      case
                         when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                            or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                               and tree.usage = 'ASSIGNMENT')
                         then
                            1
                      end
                   ) over (
                      partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                   ) = 0
                then
                   'NO'
                else
                   'YES'
             end
       end as "Used?"
  from tree_plus tree
  left join src
    on src.owner = tree.owner
   and src.type = tree.object_type
   and src.name = tree.object_name
   and src.line = tree.line
 order by length(tree.object_type), tree.line, tree.col, tree.path_len
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Statements]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       type as "Type",
       line as "Line",
       col as "Col",
       sql_id as "SQL_ID",
       case
          when (count(sql_id) over (partition by sql_id)) > 1 then
             'YES'
          else
             'NO'
       end as "Duplicate?",
       has_hint as "Has hint?",
       has_into_bulk as "Has bulk into?",
       has_into_returning as "Has returning into?",
       has_into_record as "Has into record?",
       has_current_of as "Has current of?",
       has_for_update as "Has for update?",
       has_in_binds as "Has binds?",
       full_text as "Text"
  from sys.all_statements
 where owner = :OBJECT_OWNER
   and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
   and object_name = :OBJECT_NAME
 order by length(object_type), line, col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Uses]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   ids as (
      select /*+ materialize */
             owner,
             object_type,
             object_name,
             signature,
             usage,
             type,
             name,
             line,
             col
        from sys.all_identifiers
       where usage in ('CALL', 'REFERENCE')
         and (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
         ' BODY')
         and object_name = :OBJECT_NAME
   )
select case
          when ids.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || ids.owner
             || ':'
             || ids.object_type
             || ':'
             || ids.object_name
             || ':'
             || to_char(ids.line, 'FM0000009')
             || ':'
             || to_char(ids.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       case
          when refs.object_type = 'SYNONYM' then
             s.table_owner
          else
             refs.owner
       end as "Owner",
       case
          when refs.object_type = 'SYNONYM' then
             o.object_type
          else
             refs.object_type
       end as "Object type",
       case
          when refs.object_type = 'SYNONYM' then
             s.table_name
          else
             refs.object_name
       end as "Object name",
       ids.usage as "Usage",
       ids.type as "Type",
       ids.name as "Name",
       ids.line as "Line",
       ids.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text" -- remove trailing new line character
  from ids
  join sys.all_identifiers refs
    on ids.signature = refs.signature
  left join src
    on src.owner = ids.owner
   and src.type = ids.object_type
   and src.name = ids.object_name
   and src.line = ids.line
  left join sys.all_synonyms s
    on s.owner = refs.owner
   and s.synonym_name = refs.object_name
  left join sys.all_objects o
    on o.owner = s.table_owner
   and o.object_name = s.table_name
 where refs.usage = 'DECLARATION'
   and not (
          refs.owner = :OBJECT_OWNER
          and refs.object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
          ' BODY')
          and refs.object_name = :OBJECT_NAME
       )
   and not (
          refs.owner = 'SYS'
          and refs.object_type = 'PACKAGE'
          and refs.object_name = 'STANDARD'
       )
 order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view">
		<name><![CDATA[Used by]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   refs as (
      select /*+materialize */
             signature
        from sys.all_identifiers refs
       where usage = 'DECLARATION'
         and (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type = upper(replace(:OBJECT_TYPE, 'plscope-utils-'))
         and object_name = :OBJECT_NAME
   )
select case
          when ids.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || ids.owner
             || ':'
             || ids.object_type
             || ':'
             || ids.object_name
             || ':'
             || to_char(ids.line, 'FM0000009')
             || ':'
             || to_char(ids.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       ids.owner as "Owner",
       ids.object_type as "Object type",
       ids.object_name as "Object name",
       ids.usage as "Usage",
       ids.type as "Type",
       ids.name as "Name",
       ids.line as "Line",
       ids.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text" -- remove trailing new line character
  from refs
  join sys.all_identifiers ids
    on ids.signature = refs.signature
  left join src
    on src.owner = ids.owner
   and src.type = ids.object_type
   and src.name = ids.object_name
   and src.line = ids.line
 where not (
          ids.owner = :OBJECT_OWNER
          and ids.object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
          ' BODY')
          and ids.object_name = :OBJECT_NAME
       )
 order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Table Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             ':' || nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where owner = :OBJECT_OWNER
         and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
         ' BODY')
         and object_name = :OBJECT_NAME
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             tree.line,
             tree.col,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             regexp_replace(src.text, chr(10) || '+$', null) as text, -- remove trailing new line character
             case
                when tree.name_path like '%:%'
                   and tree.usage != 'EXECUTE'
                then
                   -- ensure that this is really a child of a statement
                   last_value (
                      case
                         when tree.usage = 'EXECUTE' then
                            tree.signature
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_name, tree.object_type
                      order by tree.line, tree.col, tree.path_len
                   )
             end as parent_statement_signature,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   ),
   dep as (
      select owner as owner,
             'TABLE' as type,
             table_name as name,
             null as referenced_owner,
             null as referenced_type,
             null as referenced_name
        from sys.all_tables
      union all
      select owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        from sys.all_dependencies
       where type in ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   -- recursive with clause to calculate ref_object_type_path
   dep_graph_base (
      owner,
      object_type,
      object_name,
      ref_owner,
      ref_object_type,
      ref_object_name,
      ref_object_type_path,
      path_len
   ) as (
      select owner,
             type,
             name,
             owner as ref_owner,
             type as ref_object_type,
             name as ref_object_name,
             '/' || type as ref_object_type_path,
             1 as path_len
        from dep
      union all
      select dep.owner,
             dep.type,
             dep.name,
             dep_graph_base.ref_owner,
             dep_graph_base.ref_object_type,
             dep_graph_base.ref_object_name,
             case
                when lengthb(dep_graph_base.ref_object_type_path) + lengthb('/') + lengthb(dep.type) <= 4000 then
                   dep_graph_base.ref_object_type_path
                   || '/'
                   || dep.type
                else
                   -- prevent ref_object_type_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(dep_graph_base.ref_object_type_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(dep_graph_base.ref_object_type_path, instr(dep_graph_base.ref_object_type_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(dep.type)),
                      '^[^/]*')
                   || '/'
                   || dep.type
             end as ref_object_type_path,
             dep_graph_base.path_len + 1 as path_len
        from dep_graph_base
        join dep
          on dep_graph_base.owner = dep.referenced_owner
         and dep_graph_base.object_type = dep.referenced_type
         and dep_graph_base.object_name = dep.referenced_name
   ) cycle owner, object_type, object_name set is_cycle to 'Y' default 'N',
   -- remove duplicate rows
   dep_graph as (
      select distinct
             owner,
             object_type,
             object_name,
             ref_owner,
             ref_object_type,
             ref_object_name,
             ref_object_type_path,
             path_len
        from dep_graph_base
   ),
   plscope_tab_usage as (
      select /*+use_hash(ids) use_hash(dep_graph) use_hash(refs)*/
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             case
                when dep_graph.path_len = 1 then
                   'YES'
                else
                   'NO'
             end as direct_dependency,
             dep_graph.ref_object_type_path,
             lead(dep_graph.ref_object_type_path) over (
                order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col, dep_graph.path_len
             ) as next_ref_object_type_path,
             ids.text,
             dep_graph.path_len
        from plscope_identifiers ids
        join dep_graph
          on dep_graph.owner = ids.ref_owner
         and dep_graph.object_type = ids.ref_object_type
         and dep_graph.object_name = ids.ref_object_name
        left join sys.all_statements refs
          on refs.signature = parent_statement_signature
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       procedure_name as "Procedure name",
       operation as "Operation",
       direct_dependency as "Direct dep?",
       ref_owner as "Owner",
       ref_object_type as "Object type",
       ref_object_name as "Object name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_tab_usage
 where (ref_object_type != 'SYNONYM' or next_ref_object_type_path in ('/VIEW/SYNONYM', '/TABLE/SYNONYM'))
   -- resolve synonyms as indirect dependencies only (do not resolve table usages in views)
   and (path_len = 1 or path_len = 2 and ref_object_type_path like '%SYNONYM')
 order by length(object_type), line, col, path_len
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Column Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   prep_ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_identifiers
      union all
      select owner,
             ':' || nvl(sql_id, type) as name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
        from sys.all_statements
   ),
   fids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        from prep_ids
       where owner = :OBJECT_OWNER
         and object_type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) ||
         ' BODY')
         and object_name = :OBJECT_NAME
   ),
   base_ids as (
      select fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when fk.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        from fids
        left join fids fk
          on fk.owner = fids.owner
         and fk.object_type = fids.object_type
         and fk.object_name = fids.object_name
         and fk.usage_id = fids.usage_context_id
   ),
   ids as (
      select owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                         when sane_fk = 'YES' then
                            usage_id
                      end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id -- fix broken hierarchies
        from base_ids
   ),
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   plscope_identifiers as (
      select /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                case
                   when tree.type in ('PROCEDURE', 'FUNCTION')
                      and tree.path_len = 2
                   then
                      tree.name
                end
             ) ignore nulls over (
                partition by tree.owner, tree.object_name, tree.object_type
                order by tree.line, tree.col, tree.path_len
             ) as procedure_name,
             tree.line,
             tree.col,
             replace(tree.name, ':', null) as name, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner as ref_owner,
             refs.object_type as ref_object_type,
             refs.object_name as ref_object_name,
             case
                when tree.name_path like '%:%'
                   and tree.usage != 'EXECUTE'
                then
                   -- ensure that this is really a child of a statement
                   last_value (
                      case
                         when tree.usage = 'EXECUTE' then
                            tree.signature
                      end
                   ) ignore nulls over (
                      partition by tree.owner, tree.object_name, tree.object_type
                      order by tree.line, tree.col, tree.path_len
                   )
             end as parent_statement_signature,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        from tree
        left join sys.all_identifiers refs
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
   ),
   dep as (
      select owner as owner,
             'TABLE' as type,
             table_name as name,
             null as referenced_owner,
             null as referenced_type,
             null as referenced_name
        from sys.all_tables
      union all
      select owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        from sys.all_dependencies
       where type in ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   -- recursive with clause to calculate ref_object_type_path
   dep_graph_base (
      owner,
      object_type,
      object_name,
      ref_owner,
      ref_object_type,
      ref_object_name,
      ref_object_type_path,
      path_len
   ) as (
      select owner,
             type,
             name,
             owner as ref_owner,
             type as ref_object_type,
             name as ref_object_name,
             '/' || type as ref_object_type_path,
             1 as path_len
        from dep
      union all
      select dep.owner,
             dep.type,
             dep.name,
             dep_graph_base.ref_owner,
             dep_graph_base.ref_object_type,
             dep_graph_base.ref_object_name,
             case
                when lengthb(dep_graph_base.ref_object_type_path) + lengthb('/') + lengthb(dep.type) <= 4000 then
                   dep_graph_base.ref_object_type_path
                   || '/'
                   || dep.type
                else
                   -- prevent ref_object_type_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(dep_graph_base.ref_object_type_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(dep_graph_base.ref_object_type_path, instr(dep_graph_base.ref_object_type_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(dep.type)),
                      '^[^/]*')
                   || '/'
                   || dep.type
             end as ref_object_type_path,
             dep_graph_base.path_len + 1 as path_len
        from dep_graph_base
        join dep
          on dep_graph_base.owner = dep.referenced_owner
         and dep_graph_base.object_type = dep.referenced_type
         and dep_graph_base.object_name = dep.referenced_name
   ) cycle owner, object_type, object_name set is_cycle to 'Y' default 'N',
   -- remove duplicate rows
   dep_graph as (
      select distinct
             owner,
             object_type,
             object_name,
             ref_owner,
             ref_object_type,
             ref_object_name,
             ref_object_type_path,
             path_len
        from dep_graph_base
   ),
   plscope_tab_usage as (
      select /*+use_hash(ids) use_hash(dep_graph) use_hash(refs)*/
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             ids.path_len,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             case
                when dep_graph.path_len = 1 then
                   'YES'
                else
                   'NO'
             end as direct_dependency
        from plscope_identifiers ids
        left join sys.all_statements refs
          on refs.signature = parent_statement_signature
        join dep_graph
          on dep_graph.owner = ids.ref_owner
         and dep_graph.object_type = ids.ref_object_type
         and dep_graph.object_name = ids.ref_object_name
       where ids.type in ('VIEW', 'TABLE', 'MATERIALIZED VIEW', 'SYNONYM')
         and not (ids.type = 'SYNONYM' and refs.type in ('PROCEDURE', 'FUNCTION'))
   ),
   scope_cols as (
      select /*+use_hash(ids) use_hash(refs) */
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.name as column_name,
             ids.path_len
        from plscope_identifiers ids
        left join sys.all_statements refs
          on refs.signature = parent_statement_signature
       where ids.type = 'COLUMN'
         and ids.usage != 'DECLARATION'
   ),
   missing_cols as (
      select /*+use_hash(t) use_hash(s) use_hash(o) use_hash(c) use_hash(tc) */
             t.owner,
             t.object_type,
             t.object_name,
             t.line,
             t.col,
             t.procedure_name,
             t.operation,
             coalesce(o.owner, t.ref_owner) as ref_owner,
             coalesce(o.object_type, t.ref_object_type) as ref_object_type,
             coalesce(o.object_name, t.ref_object_name) as ref_object_name,
             tc.column_name,
             t.path_len
        from plscope_tab_usage t
        left join sys.all_synonyms s
          on s.owner = t.ref_owner
         and s.synonym_name = t.ref_object_name
        left join sys.all_objects o
          on o.owner = s.table_owner
         and o.object_name = s.table_name
        left join scope_cols c
          on t.owner = c.owner
         and t.object_type = c.object_type
         and t.object_name = c.object_name
         and t.procedure_name = c.procedure_name
         and coalesce(o.owner, t.ref_owner) = c.ref_owner
         and coalesce(o.object_type, t.ref_object_type) = c.ref_object_type
         and coalesce(o.object_name, t.ref_object_name) = c.ref_object_name
        join sys.all_tab_columns tc
          on tc.owner = t.owner
         and tc.table_name = coalesce(o.object_name, t.ref_object_name)
       where direct_dependency = 'YES'
         and c.owner is null
         and t.operation in ('INSERT', 'SELECT')
   ),
   base_cols as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             path_len,
             'YES' as direct_dependency
        from scope_cols
      union all
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             path_len,
             'NO' as direct_dependency
        from missing_cols
   )
select case
          when base_cols.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY')
          then
             'SQLDEV:LINK:'
             || base_cols.owner
             || ':'
             || base_cols.object_type
             || ':'
             || base_cols.object_name
             || ':'
             || to_char(base_cols.line, 'FM0000009')
             || ':'
             || to_char(base_cols.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       base_cols.procedure_name as "Procedure name",
       base_cols.operation as "Operation",
       base_cols.direct_dependency as "Direct dep?",
       base_cols.ref_owner "Owner",
       base_cols.ref_object_type as "Object type",
       base_cols.ref_object_name as "Object name",
       base_cols.column_name as "Column name",
       base_cols.line as "Line",
       base_cols.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text" -- remove trailing new line character
  from base_cols
  left join src
    on src.owner = base_cols.owner
   and src.type = base_cols.object_type
   and src.name = base_cols.object_name
   and src.line = base_cols.line
 order by length(base_cols.object_type), base_cols.line, base_cols.col, base_cols.path_len
]]>
               </sql>
			</query>
		</queries>
	</display>
</displays>
