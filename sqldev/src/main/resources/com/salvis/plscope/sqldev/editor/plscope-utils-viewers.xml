<?xml version="1.0" encoding="UTF-8"?>
<displays>
	<!-- based on -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_identifiers.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_statements.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_tab_usage.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_col_usage.sql -->
	<!-- used sys.all_ instead of dba_ - SQL Developer uses dba_ views, if the connected user has the privileges -->
	<!-- Use case sensitive result columns including spaces -->
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,SEQUENCE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view,plscope-utils-sequence">
		<name><![CDATA[Identifiers]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   -- database source filtered by SQLDEV bind variables
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   -- PL/SQL identifiers filtered by SQLDEV bind variables
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and object_name = :OBJECT_NAME
   ),
   -- SQL identifiers filtered by SQLDEV bind variables
   sql_ids as (
      select /*+ materialize */
             owner,
             nvl(sql_id, type) as name,
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_statements -- NOSONAR: avoid public synonym
       where (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and object_name = :OBJECT_NAME
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
      union all
      select 'YES' as is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             null as procedure_scope,
             origin_con_id
        from sql_ids
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the name_usage column to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                when tree.usage = 'SQL_ID' then
                   tree.type || ' statement (sql_id: ' || tree.name || ')'
                when tree.usage = 'SQL_STMT' then
                   tree.type || ' statement'
                else
                   tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
             end as name_usage                                       -- @formatter:on
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage, and add the text, is_used,
      -- ref_line, and ref_col columns to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                   -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             case
                   -- wrong result, if used in statements which do not register usage,
                   -- such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE.
                   -- Bug 26351814.
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
select case
          when object_type in (
                'FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY', 'TABLE',
                'VIEW', 'SEQUENCE', 'SYNONYM'
             )
          then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       name_usage as "Name (Type, Usage)",
       line as "Line",
       col as "Col",
       text as "Text",
       name as "Name",
       type as "Type",
       usage as "Usage",
       is_used as "Used?"
  from plscope_identifiers
 order by length(object_type), line, col, path_len
]]>
            </sql>
			</query>
			<query minversion="11.1">
				<sql><![CDATA[
with
   -- database source filtered by SQLDEV bind variables
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   -- PL/SQL identifiers filtered by SQLDEV bind variables
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             0 as origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and object_name = :OBJECT_NAME
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the name_usage column to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                when tree.usage = 'SQL_ID' then
                   tree.type || ' statement (sql_id: ' || tree.name || ')'
                when tree.usage = 'SQL_STMT' then
                   tree.type || ' statement'
                else
                   tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
             end as name_usage                                       -- @formatter:on
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage, and add the text, is_used,
      -- ref_line, and ref_col columns to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                   -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             case
                   -- wrong result, if used in statements which do not register usage,
                   -- such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE.
                   -- Bug 26351814.
                when tree.object_type in ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                   and tree.usage = 'DECLARATION'
                   and tree.type not in ('LABEL')
                then
                   case
                      when count(
                            case
                               when tree.usage not in ('DECLARATION', 'ASSIGNMENT')
                                  or (tree.type in ('FORMAL OUT', 'FORMAL IN OUT')
                                     and tree.usage = 'ASSIGNMENT')
                               then
                                  1
                            end
                         ) over (
                            partition by tree.owner, tree.object_name, tree.object_type, tree.signature
                         ) = 0
                      then
                         'NO'
                      else
                         'YES'
                   end
             end as is_used,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   )
select case
          when object_type in (
                'FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY', 'TABLE',
                'VIEW', 'SEQUENCE', 'SYNONYM'
             )
          then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       name_usage as "Name (Type, Usage)",
       line as "Line",
       col as "Col",
       text as "Text",
       name as "Name",
       type as "Type",
       usage as "Usage",
       is_used as "Used?"
  from plscope_identifiers
 order by length(object_type), line, col, path_len
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Statements]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   plscope_statements as (
      select owner,
             signature,
             type,
             object_name,
             object_type,
             usage_id,
             line,
             col,
             usage_context_id,
             sql_id,
             case
                when (count(sql_id) over (partition by sql_id)) > 1 then
                   'YES'
                else
                   'NO'
             end as is_duplicate,
             has_hint,
             has_into_bulk,
             has_into_returning,
             has_into_record,
             has_current_of,
             has_for_update,
             has_in_binds,
             text,
             full_text,
             origin_con_id
        from sys.all_statements stmt -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       type as "Type",
       line as "Line",
       col as "Col",
       sql_id as "SQL_ID",
       is_duplicate as "Duplicate?",
       has_hint as "Has hint?",
       has_into_bulk as "Has bulk into?",
       has_into_returning as "Has returning into?",
       has_into_record as "Has into record?",
       has_current_of as "Has current of?",
       has_for_update as "Has for update?",
       has_in_binds as "Has binds?",
       full_text as "Text"
  from plscope_statements
 order by length(object_type), line, col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Uses]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner = :OBJECT_OWNER
         and type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and name = :OBJECT_NAME
   ),
   ids as (
      select /*+ materialize */
             owner,
             object_type,
             object_name,
             signature,
             usage,
             type,
             name,
             line,
             col
        from sys.all_identifiers
       where usage in ('CALL', 'REFERENCE')
         and (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   )
select case
          when ids.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || ids.owner
             || ':'
             || ids.object_type
             || ':'
             || ids.object_name
             || ':'
             || to_char(ids.line, 'FM0000009')
             || ':'
             || to_char(ids.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       case
          when refs.object_type = 'SYNONYM' then
             s.table_owner
          else
             refs.owner
       end as "Owner",
       case
          when refs.object_type = 'SYNONYM' then
             o.object_type
          else
             refs.object_type
       end as "Object type",
       case
          when refs.object_type = 'SYNONYM' then
             s.table_name
          else
             refs.object_name
       end as "Object name",
       ids.usage as "Usage",
       ids.type as "Type",
       ids.name as "Name",
       ids.line as "Line",
       ids.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text" -- remove trailing new line character
  from ids
  join sys.all_identifiers refs
    on ids.signature = refs.signature
  left join src
    on src.owner = ids.owner
   and src.type = ids.object_type
   and src.name = ids.object_name
   and src.line = ids.line
  left join sys.all_synonyms s
    on s.owner = refs.owner
   and s.synonym_name = refs.object_name
  left join sys.all_objects o
    on o.owner = s.table_owner
   and o.object_name = s.table_name
 where refs.usage = 'DECLARATION'
   and not (
          refs.owner = :OBJECT_OWNER
          and refs.object_type in (
             upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
          )
          and refs.object_name = :OBJECT_NAME
       )
   and not (
          refs.owner = 'SYS'
          and refs.object_type = 'PACKAGE'
          and refs.object_name = 'STANDARD'
       )
 order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,SEQUENCE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view,plscope-utils-sequence">
		<name><![CDATA[Used by]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
with
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source
       where owner = :OBJECT_OWNER
         and type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and name = :OBJECT_NAME
   ),
   refs as (
      select /*+materialize */
             signature
        from sys.all_identifiers refs
       where usage = 'DECLARATION'
         and (owner = :OBJECT_OWNER or upper(replace(:OBJECT_TYPE, 'plscope-utils-')) = 'SYNONYM')
         and object_type = upper(replace(:OBJECT_TYPE, 'plscope-utils-'))
         and object_name = :OBJECT_NAME
   )
select case
          when ids.object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || ids.owner
             || ':'
             || ids.object_type
             || ':'
             || ids.object_name
             || ':'
             || to_char(ids.line, 'FM0000009')
             || ':'
             || to_char(ids.col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       ids.owner as "Owner",
       ids.object_type as "Object type",
       ids.object_name as "Object name",
       ids.usage as "Usage",
       ids.type as "Type",
       ids.name as "Name",
       ids.line as "Line",
       ids.col as "Col",
       regexp_replace(src.text, chr(10) || '+$', null) as "Text" -- remove trailing new line character
  from refs
  join sys.all_identifiers ids
    on ids.signature = refs.signature
  left join src
    on src.owner = ids.owner
   and src.type = ids.object_type
   and src.name = ids.object_name
   and src.line = ids.line
 where not (
          ids.owner = :OBJECT_OWNER
          and ids.object_type in (
             upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
          )
          and ids.object_name = :OBJECT_NAME
       )
 order by ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Table Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   -- database source filtered by SQLDev bind variables
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   -- PL/SQL identifiers filtered by SQLDev bind variables
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   ),
   -- SQL identifiers filtered by SQLDev bind variables
   sql_ids as (
      select /*+ materialize */
             owner,
             nvl(sql_id, type) as name,
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_statements -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
      union all
      select 'YES' as is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             null as procedure_scope,
             origin_con_id
        from sql_ids
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the name_usage column to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage                                    -- @formatter:on
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage, and add the text, ref_line,
      -- and ref_col columns to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   ),
   table_usage_ids as ( 
      select /*+ materialize */
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.procedure_name,
             ids.usage,
             ids.line,
             ids.col,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.parent_statement_signature,
             ids.text
        from plscope_identifiers ids
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
   ),
   -- direct and indirect dependencies; path_len = 0 for direct dependencies, 
   -- otherwise the length of the chain of dependencies, i.e. level - 1; cycles
   -- are possible here (with help from synonyms) so we need to detect them
   dep_chains (
      owner,
      type,
      name,
      ref_owner,
      ref_type,
      ref_name,
      path_len
   ) as (
      -- direct dependencies
      select distinct
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             0
        from table_usage_ids ids
       where ids.ref_object_type in ('VIEW', 'TABLE', 'SYNONYM')
       union all
      -- indirect dependencies
      select /*+ no_merge(dep) */ 
             par.owner,
             par.type,
             par.name,
             dep.referenced_owner,
             dep.referenced_type,
             dep.referenced_name,
             par.path_len + 1
        from dep_chains par
        join sys.all_dependencies dep  -- NOSONAR: avoid public synonym
          on par.ref_owner = dep.owner
         and par.ref_type = dep.type
         and par.ref_name = dep.name
       where par.ref_type <> 'VIEW'    -- don't resolve table usages in views
         and dep.referenced_type in (  -- list of referenced types of interest
            'VIEW', 
            'TABLE', 
            'SYNONYM',
            'MATERIALIZED VIEW'        -- does MATERIALIZED VIEW belong here?
         )
   )
   cycle ref_owner, ref_type, ref_name set is_cycle to 'Y' default 'N',
   -- eliminate duplicate dependencies, keeping the minimum path_len; add the 
   -- base_object_type column, which is the type of the first object (if any)
   -- which is not a synonym, in case we're going down a chain of synonyms
   dep_trans_closure as (
      select owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name,
             min(path_len)  as path_len,
             nullif(                            -- @formatter:off
                min(ref_type)
                keep (
                   dense_rank first
                   order by 
                      case
                         when ref_type = 'SYNONYM' then
                            null
                         else
                            min(path_len)
                      end asc nulls last,
                      min(path_len)
                )
                over (
                   partition by owner, type, name
                ),
                'SYNONYM'
             )  as base_obj_type                -- @formatter:on
        from dep_chains
       group by owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name      
   ),
   plscope_tab_usage as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             dep.ref_owner,
             dep.ref_type  as ref_object_type,
             dep.ref_name  as ref_object_name,
             case
                when dep.path_len = 0 then
                   'YES'
                else
                   'NO'
             end as direct_dependency,
             ids.text,
             dep.path_len
        from table_usage_ids ids
        join dep_trans_closure dep
          on dep.owner = ids.ref_owner
         and dep.type = ids.ref_object_type
         and dep.name = ids.ref_object_name
         and dep.base_obj_type is not null  -- drop syn. refs not leading to tables/views
        left join sys.all_statements refs   -- NOSONAR: avoid public synonym
          on refs.signature = ids.parent_statement_signature
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       procedure_name as "Procedure name",
       operation as "Operation",
       direct_dependency as "Direct dep?",
       ref_owner as "Owner",
       ref_object_type as "Object type",
       ref_object_name as "Object name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_tab_usage
 where -- skip intermediate synonyms
       not (ref_object_type = 'SYNONYM' and path_len >= 1)
 order by length(object_type), line, col, path_len
]]>
            </sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Column Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
with
   -- database source filtered by SQLDev bind variables
   src as (
      select /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        from sys.all_source -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and type in (upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY')
         and name = :OBJECT_NAME
   ),
   -- PL/SQL identifiers filtered by SQLDev bind variables
   pls_ids as (
      select /*+ materialize */
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_identifiers -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   ),
   -- SQL identifiers filtered by SQLDev bind variables
   sql_ids as (
      select /*+ materialize */
             owner,
             nvl(sql_id, type) as name,
             signature,
             type,
             object_name,
             object_type,
             nvl2(sql_id, 'SQL_ID', 'SQL_STMT') as usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        from sys.all_statements -- NOSONAR: avoid public synonym
       where owner = :OBJECT_OWNER
         and object_type in (
                upper(replace(:OBJECT_TYPE, 'plscope-utils-')), upper(replace(:OBJECT_TYPE, 'plscope-utils-')) || ' BODY'
             )
         and object_name = :OBJECT_NAME
   ),
   -- full list of identifiers (PL/SQL and SQL) with columns is_sql_stmt and procedure_scope
   fids as (
      select 'NO' as is_sql_stmt,
             pls_ids.owner,
             pls_ids.name,
             pls_ids.signature,
             pls_ids.type,
             pls_ids.object_name,
             pls_ids.object_type,
             pls_ids.usage,
             pls_ids.usage_id,
             pls_ids.line,
             pls_ids.col,
             pls_ids.usage_context_id,
             nvl2(sig.signature, 'PUBLIC', cast(null as varchar2(7 char))) as procedure_scope,
             pls_ids.origin_con_id
        from pls_ids
        left join pls_ids sig
          on sig.owner = pls_ids.owner
         and sig.object_type = 'PACKAGE'
         and sig.object_name = pls_ids.object_name
         and sig.usage = 'DECLARATION'
         and sig.signature = pls_ids.signature
      union all
      select 'YES' as is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             null as procedure_scope,
             origin_con_id
        from sql_ids
   ),
   -- add column sane_fk to list of identifiers
   base_ids as (
      select fids.is_sql_stmt,
             fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             case
                when parent.usage_id is not null
                   or fids.usage_context_id = 0
                then
                   'YES'
                else
                   'NO'
             end as sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id,
             fids.procedure_scope,
             fids.origin_con_id
        from fids
        left join fids parent
          on parent.owner = fids.owner
         and parent.object_type = fids.object_type
         and parent.object_name = fids.object_name
         and parent.usage_id = fids.usage_context_id
   ),
   -- add columns usage_context_id, is_fixed_context_id to list of identifiers
   ids as (
      select is_sql_stmt,
             owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             case
                when sane_fk = 'YES' then
                   usage_context_id
                else
                   last_value(case
                                 when sane_fk = 'YES' then
                                    usage_id
                              end) ignore nulls over (
                      partition by owner, object_name, object_type
                      order by line, col, usage_id
                      rows between unbounded preceding and 1 preceding
                   )
             end as usage_context_id,        -- fix broken hierarchies
             case
                when sane_fk = 'NO' then
                   cast('YES' as varchar2(3 char))
             end as is_fixed_context_id,     -- indicator of fixed hierarchies
             procedure_scope,
             origin_con_id
        from base_ids
   ),
   -- recursive with clause to extend the list of identifiers with the columns
   -- procedure_name, procedure_scope, name_path, path_len (level), procedure_signature,
   -- parent_statement_type, parent_statement_signature, parent_statement_path_len
   tree (
      owner,
      object_type,
      object_name,
      line,
      col,
      procedure_name,
      procedure_scope,
      name,
      name_path,
      path_len,
      type,
      usage,
      signature,
      usage_id,
      usage_context_id,
      is_fixed_context_id,
      procedure_signature,
      is_sql_stmt,
      parent_statement_type,
      parent_statement_signature,
      parent_statement_path_len,
      origin_con_id
   ) as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   name
             end as procedure_name,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   cast('PUBLIC' as varchar2(7 char))
             end as procedure_scope,
             name,
             '/' || name as name_path,
             1 as path_len,
             type,
             usage,
             signature,
             usage_id,
             usage_context_id,
             is_fixed_context_id,
             case
                when object_type in ('PROCEDURE', 'FUNCTION') then
                   signature
             end as procedure_signature,
             is_sql_stmt,
             cast(null as varchar2(18 char)) as parent_statement_type,
             cast(null as varchar2(32 char)) as parent_statement_signature,
             cast(null as number) as parent_statement_path_len,
             origin_con_id
        from ids
       where usage_context_id = 0  -- top-level identifiers
      union all
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             case
                when tree.procedure_name is not null then
                   tree.procedure_name
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.name
             end as procedure_name,
             case
                when tree.procedure_scope is not null then
                   tree.procedure_scope
                when ids.object_type = 'PACKAGE'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage = 'DECLARATION'
                   and ids.usage_context_id = 1
                then
                   'PUBLIC'
                when ids.object_type = 'PACKAGE BODY'
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   case ids.procedure_scope
                      when 'PUBLIC' then
                         'PUBLIC'
                      else
                         'PRIVATE'
                   end
             end as procedure_scope,
             ids.name,
             case
                when lengthb(tree.name_path) + lengthb('/') + lengthb(ids.name) <= 4000 then
                   tree.name_path
                   || '/'
                   || ids.name
                else
                   -- prevent name_path from overflowing: keep the first 3 elements, then
                   -- remove enough elements to accomodate "..." + "/" + the tail end
                   regexp_substr(tree.name_path, '^(/([^/]+/){3})')
                   || '...'
                   || regexp_replace(
                      substr(tree.name_path, instr(tree.name_path, '/', 1, 4) + 1
                         + lengthb('.../') + lengthb(ids.name)),
                      '^[^/]*')
                   || '/'
                   || ids.name
             end as name_path,
             tree.path_len + 1 as path_len,
             ids.type,
             ids.usage,
             ids.signature,
             ids.usage_id,
             ids.usage_context_id,
             ids.is_fixed_context_id,
             case
                when tree.procedure_signature is not null then
                   tree.procedure_signature
                when ids.object_type in ('PACKAGE', 'PACKAGE BODY')
                   and ids.type in ('FUNCTION', 'PROCEDURE')
                   and ids.usage in ('DEFINITION', 'DECLARATION')
                   and ids.usage_context_id = 1
                then
                   ids.signature
             end as procedure_signature,
             ids.is_sql_stmt,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.type
                else
                   tree.parent_statement_type
             end as parent_statement_type,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.signature
                else
                   tree.parent_statement_signature
             end as parent_statement_signature,
             case
                when tree.is_sql_stmt = 'YES' then
                   tree.path_len
                else
                   tree.parent_statement_path_len
             end as parent_statement_path_len,
             ids.origin_con_id
        from tree
        join ids
          on tree.owner = ids.owner
         and tree.object_type = ids.object_type
         and tree.object_name = ids.object_name
         and tree.usage_id = ids.usage_context_id
   ) cycle owner, object_type, object_name, usage_id set is_cycle to 'Y' default 'N',
   -- add the name_usage column to the list of identifiers
   tree_plus as (
      select tree.*,                                                 -- @formatter:off
             case
                   when tree.usage = 'SQL_ID' then
                      tree.type || ' statement (sql_id: ' || tree.name || ')'
                   when tree.usage = 'SQL_STMT' then
                      tree.type || ' statement'
                   else
                      tree.name || ' (' || lower(tree.type) || ' ' || lower(tree.usage) || ')'
                end as name_usage                                    -- @formatter:on
        from tree
   ),
   plscope_identifiers as (
      -- add indent to column name_usage, fix column usage, and add the text, ref_line,
      -- and ref_col columns to the list of identifiers
      select tree.owner,
             tree.object_type,
             tree.object_name,
             tree.line,
             tree.col,
             tree.procedure_name,
             tree.procedure_scope,
             cast(
                -- left indent name_usage according to path_len, wrapping to the left
                -- if necessary so as not to exceed a limit of 250 characters
                case
                   when mod(2 * (tree.path_len - 1), 250) + length(tree.name_usage) <= 250 then
                      lpad(' ', mod(2 * (tree.path_len - 1), 250)) || tree.name_usage
                   else
                      substr(tree.name_usage, 250 - mod(2 * (tree.path_len - 1), 250)
                         - length(tree.name_usage))
                      || lpad(' ', 250 - length(tree.name_usage))
                      || substr(tree.name_usage, 1, 250 - mod(2 * (tree.path_len - 1), 250))
                end
                as varchar2(250 char)
             ) as name_usage,
             tree.name,
             tree.name_path,
             tree.path_len,
             tree.type,
             case
                -- make SQL_ID and SQL_STMT pseudo-usages appear as EXECUTE
                when tree.usage in ('SQL_ID', 'SQL_STMT') then
                   'EXECUTE'
                else
                   tree.usage
             end as usage,
             refs.owner as ref_owner,                 -- decl_owner
             refs.object_type as ref_object_type,     -- decl_object_type
             refs.object_name as ref_object_name,     -- decl_object_name
             regexp_replace(src.text, chr(10) || '+$', null) as text,  -- remove trailing new line character
             tree.parent_statement_type,
             tree.parent_statement_signature,
             tree.parent_statement_path_len,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id,
             tree.is_fixed_context_id,
             tree.procedure_signature,
             refs.line as ref_line,         -- decl_line
             refs.col as ref_col,           -- decl_col
             tree.origin_con_id
        from tree_plus tree
        left join sys.all_identifiers refs -- must not used pls_ids to consider all identifiers
          on refs.signature = tree.signature
         and refs.usage = 'DECLARATION'
        left join src
          on src.owner = tree.owner
         and src.type = tree.object_type
         and src.name = tree.object_name
         and src.line = tree.line
   ),
   tableorcolumn_usage_ids as ( 
      select /*+ materialize */
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.procedure_name,
             ids.type,
             ids.name,
             ids.usage,
             ids.line,
             ids.col,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.parent_statement_signature,
             ids.text,
             ids.path_len
        from plscope_identifiers ids
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
             or (ids.type = 'COLUMN' and ids.usage != 'DECLARATION')
   ),
   -- direct and indirect dependencies; path_len = 0 for direct dependencies, 
   -- otherwise the length of the dependency chain, i.e. level - 1; cycles are
   -- possible here (with help from synonyms) so we need to detect them
   dep_chains (
      owner,
      type,
      name,
      ref_owner,
      ref_type,
      ref_name,
      path_len
   ) as (
      -- direct dependencies
      select distinct
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             0
        from tableorcolumn_usage_ids ids
       where ids.ref_object_type in ('VIEW', 'TABLE', 'SYNONYM')
       union all
      -- indirect dependencies
      select /*+ no_merge(dep) */ 
             par.owner,
             par.type,
             par.name,
             dep.referenced_owner,
             dep.referenced_type,
             dep.referenced_name,
             par.path_len + 1
        from dep_chains par
        join sys.all_dependencies dep  -- NOSONAR: avoid public synonym
          on par.ref_owner = dep.owner
         and par.ref_type = dep.type
         and par.ref_name = dep.name
       where par.ref_type <> 'VIEW'    -- don't resolve table usages in views
         and dep.referenced_type in (  -- list of referenced types of interest
                'VIEW', 
                'TABLE', 
                'SYNONYM',
                'MATERIALIZED VIEW'    -- does MATERIALIZED VIEW belong here?
             )
   )
   cycle ref_owner, ref_type, ref_name set is_cycle to 'Y' default 'N',
   -- eliminate duplicate dependencies, keeping the minimum path_len; add the 
   -- base_object_type column, which is the type of the first object (if any)
   -- which is not a synonym, in case we're going down a chain of synonyms;
   -- the is_base_object flag is set to 'YES' for that object, otherwise null
   dep_trans_closure as (
      select owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name,
             min(path_len)  as path_len,
             nullif(                            -- @formatter:off
                min(ref_type)
                keep (
                   dense_rank first
                   order by 
                      case
                         when ref_type = 'SYNONYM' then
                            null
                         else
                            min(path_len)
                      end asc nulls last,
                      min(path_len)
                )
                over (
                   partition by owner, type, name
                ),
                'SYNONYM'
             )  as base_obj_type,               -- @formatter:on
             case                               -- @formatter:off
                -- remark: disregarding the case when there are only SYNONYMs in the 
                -- dependency chain: such chains are filtered out in tab_usage subquery
                when min(path_len) = min(min(path_len))
                      keep (
                         dense_rank first
                         order by 
                            case
                               when ref_type = 'SYNONYM' then
                                  null
                               else
                                  min(path_len)
                            end asc nulls last,
                            min(path_len)
                      )
                      over (
                         partition by owner, type, name
                      ) 
                then
                   cast('YES' as varchar2(3 char))
             end  as is_base_object             -- @formatter:on
        from dep_chains
       group by owner,
             type,
             name,
             ref_owner,
             ref_type,
             ref_name      
   ),
   plscope_tab_usage as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             dep.ref_owner,
             dep.ref_type  as ref_object_type,
             dep.ref_name  as ref_object_name,
             case
                when dep.path_len = 0 then
                   'YES'
                else
                   'NO'
             end as direct_dependency,
             ids.text,
             dep.is_base_object,
             ids.path_len
        from tableorcolumn_usage_ids ids
        join dep_trans_closure dep
          on dep.owner = ids.ref_owner
         and dep.type = ids.ref_object_type
         and dep.name = ids.ref_object_name
        left join sys.all_statements refs   -- NOSONAR: avoid public synonym
          on refs.signature = ids.parent_statement_signature   
       where ids.type in ('VIEW', 'TABLE', 'SYNONYM')
         and dep.base_obj_type is not null  -- drop syn. refs not leading to tables/views
   ),
   scope_cols as (
      select ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             case
                when refs.type is not null then
                   refs.type
                else
                   ids.usage
             end as operation,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.name as column_name,
             ids.text,
             ids.path_len
        from tableorcolumn_usage_ids ids
        left join sys.all_statements refs -- NOSONAR: avoid public synonym
          on refs.signature = parent_statement_signature
       where ids.type = 'COLUMN'
         and ids.usage != 'DECLARATION'
   ),
   missing_cols as (
      select t.owner,
             t.object_type,
             t.object_name,
             t.line,
             t.col,
             t.procedure_name,
             t.operation,
             t.ref_owner,
             t.ref_object_type,
             t.ref_object_name,
             tc.column_name,
             t.text,
             t.path_len
        from plscope_tab_usage t
        left join scope_cols c
          on t.owner = c.owner
         and t.object_type = c.object_type
         and t.object_name = c.object_name
         and t.procedure_name = c.procedure_name
         and t.ref_owner = c.ref_owner
         and t.ref_object_type = c.ref_object_type
         and t.ref_object_name = c.ref_object_name
        join sys.all_tab_columns tc -- NOSONAR: avoid public synonym
          on tc.owner = t.owner
         and tc.table_name = t.ref_object_name
       where t.is_base_object = 'YES'
         and c.owner is null
         and t.operation in ('INSERT', 'SELECT')
   ),
   base_cols as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             'YES' as direct_dependency,
             text,
             path_len
        from scope_cols
      union all
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             'NO' as direct_dependency,
             text,
             path_len
        from missing_cols
   ),
   plscope_col_usage as (
      select owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             direct_dependency,
             text,
             path_len
        from base_cols
   )
select case
          when object_type in ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') then
             'SQLDEV:LINK:'
             || owner
             || ':'
             || object_type
             || ':'
             || object_name
             || ':'
             || to_char(line, 'FM0000009')
             || ':'
             || to_char(col, 'FM0000009')
             || ':'
             || 'Source'
             || ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          else
             null
       end as "Link",
       procedure_name as "Procedure name",
       operation as "Operation",
       direct_dependency as "Direct dep?",
       ref_owner "Owner",
       ref_object_type as "Object type",
       ref_object_name as "Object name",
       column_name as "Column name",
       line as "Line",
       col as "Col",
       text as "Text"
  from plscope_col_usage
 order by length(object_type), line, col, path_len
]]>
               </sql>
			</query>
		</queries>
	</display>
</displays>
